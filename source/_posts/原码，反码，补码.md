---
title: 原码，反码，补码和移码
date: 2019-09-19 15:50:00
tags: 基础知识
categories: 计算机原理
copyright: true
---
以下都是以有符号数为基础。
# 原码
实际上，我们把符号数字化或者符号数值化，就已经给出了一种机器数的表现形式，我们把这种方式称为 **原码表示法**   
### 定义
一共分为整数和小数
- 整数
![image](https://note.youdao.com/yws/public/resource/359e08a52f64deaac553adb0132327ad/xmlnote/A55788FFDB9A4E7F813C4A89C13CD891/11767)  
    - 第一个表达式，n代表数值上的位数，"0，x"的0表示符号位。x 是真值的数值部分
    - 例子
        - ![image](https://note.youdao.com/yws/public/resource/359e08a52f64deaac553adb0132327ad/xmlnote/AB7109D7B0B1481B9CACE32B2DF00748/11811)
- 小数
![image](https://note.youdao.com/yws/public/resource/359e08a52f64deaac553adb0132327ad/xmlnote/DF3933514B294E78B090D19E353845A3/11783)  
    - 例子
         - ![image](https://note.youdao.com/yws/public/resource/359e08a52f64deaac553adb0132327ad/xmlnote/7631FA1F4F34485EB5D3A11F9712C1A9/11787)  
{% note info %}
无论是整数的的逗号或者小数点，在计算机中是不需要存储的，这里只是我们为了阅读和理解写的  
整个表示起来，也就是，如果是整数，也就是加一个符号位，和一个逗号，如果是小数，也就是加一个符号为和一个小数点（将原来小数点的左边的那位变成符号位）。
{% endnote %}
<!--more-->
# 补码
> 用于减法的操作
```
//实际上，计算机的加法操作和平时的加法操作一样，只是缝二进一
                    无符号数      有符号数
    00001110        14              14
+   10001110        142            -14
________________
    10011100        156             0
```
{% note default %}
这里我们发现，答案是不同的，在有符号数的清空下，但是如果我们这里要是可以这样，把14+（-14）变成14-14
{% endnote %}
```
        00001110
-       00001110
__________________
            0
```
{% note default %}
这样就没有问题。但是我们发现，正数加上一个负数等于正数减去一个负数。，要根据符号为判断，很麻烦。但是要怎么把减法统一成加法。  
这里举个例子，平时我们的时钟如果走快了，本来是八点，走到了十点，那么怎么进行拨回去？
- 逆时针拨两个小时 10-2=8
- 顺时针拨10个小时 10+10=20  
可见，-2 可用 +10 代替 减法 -> 加法  
记作 -2=+10 （mod 12）  
同理 -4=+8  （mod 12）  
时钟以12为模  
{% endnote %}
这里我们就得到结论
### 补数
一个负数加上“模“ 即得该负数的补数  
一个正数和负数互为补数时，它们绝对值之和为 模 数。
## 举例
我们假设，寄存器是四位，那么就是模16，一但大于16将会舍去。
1011 -> 0000 ?
- 第一种
```
        1011
-       1011
______________
        0000
```
- 第二种
```
        0101
+       1011
______________
        10000
```
{% note info %}
这个时候多出来的 1 ，将会被舍掉，利用时钟的思想，这样的话，寄存器还是存在 0000。  
减掉1011和加上0101是等价的，互为补数。这样的减法操作可以用加法替代。  
记作 -1011 = +0101 （mod2^4）  
{% endnote %}
这里就提出了**补码**的概念  
**对于正数，补码与原码的表示相同。**  
**对于负数，原码符号位不变，数值部分按位取反，末位加1 （取反加1），此规则也同样适用于由补码求原码。**
## 定义
- **纯整数的补码**  
![image](https://note.youdao.com/yws/public/resource/359e08a52f64deaac553adb0132327ad/xmlnote/9DD3FB598B84481EA94015A9EB702008/11938)  
    - 例子：  
![image](https://note.youdao.com/yws/public/resource/359e08a52f64deaac553adb0132327ad/xmlnote/88763E7E5CB14FE88905B23F4756DA2C/11951)  
- 小数的补码  
![image](https://note.youdao.com/yws/public/resource/359e08a52f64deaac553adb0132327ad/xmlnote/2BE575AF73A546D183DBE4C52B3825FE/11954)
    - 例子 ![image](https://note.youdao.com/yws/public/resource/359e08a52f64deaac553adb0132327ad/xmlnote/45F821156EA64BCF8ADD53FA221CC0E8/11959)
# 反码
> 作为原码和补码的过渡  
{% note primary %}
**对于正数，反码与原码的表示相同。**  
**对于负数，原码符号位不变，数值部分按位取反 ，此规则也同样适用于由反码求原码。**  
表示范围和原码一样
{% endnote %}
# 原补反的相互转换
{% note primary %}
- 最高位为符号位，书写用”，“（整数）或”.“（小数）将数值部分和符号位隔开。  
- 对于正数，原码=补码=反码  
- 对于负数，符号位为 1，其数值部分  
    - 原码除符号位外每位都取反末位加 1 -> 补码。  
    - 原码除符号位外每位都取反 -> 反码
{% endnote %}
# 移码
> 易于比较大小
我们的补码是很难表示真值大小，如以下例子： 
```
十进制          二进制          补码
+21             +10101          0，10101
-21             -10101          1，01011
+31             +11111          0，11111
-31             -11111          1，00001
```
如果我们直接比较的话，我们看看-21和-31都比+21和+31来得大。直接看数值的话。这个时候我们加上 2^5 次方，如果有进位的话，将舍去进位的，这里涉及到溢出问题。
```
+10101+100000 = 110101
-10101+100000 = 001011
+11111+100000 = 111111
-11111+100000 = 000001
```
很明显，上面的就比下面的大了。   
这里就给出了移码的概念。  
{% note primary %}
**移码就是在真值 X 上加上一个常数（偏置值），通常这个常数去 2^n**
{% endnote %}
#### 定义
```
[x]移=2^n+x
（我这里理解2^n其实可以理解为科学计数法的10^n）
```
#### 总结
{% note primary %}
- 一个真值，它的补码和移码除了符号位不同，其他都相同。只要对补码的符号位取反就可以得到移码。  
- 移码保留了数的大小顺序，大的数移码也大，小的数移码也小。  
{% endnote %}
**那移码怎么找回原码**   
++比如移码0111 1110的真值++。  
减去偏置值1000 0000对应的无符号数真值128得到移码真值 :  
126-128=-2
或者：  
0111 1110-1000 0000=1111 1110  
对应真值-2


