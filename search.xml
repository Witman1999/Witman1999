<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[解决hexo引用网络图片显示错误的问题]]></title>
    <url>%2F%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86-%E5%88%9B%E5%BB%BA%E5%88%86%E6%94%AF.html</url>
    <content type="text"><![CDATA[前言我们知道，在我们编程开发的时候，和别人合作，会遇到对同一个项目开发，你可能写得他快，会导致对项目的覆盖。或者你还没写完就提交上去，会导致别人看不懂，但是不提交上去又有丢失进度的风险。特别是对于大型的项目，不对项目做出分支，会造成很多冲突，你的可能会把被人的覆盖掉，别人会不乐意这样做，无形中就造成了矛盾。利用Git的分支和合并管理方法，在我们所在的项目（master分支）上建立一个分支，你在分支上的可以进行更改包括上传自己的进度，等到完成时在合并到 master 分支上。还有退回版本等等操作。这里可以这样想，我们从 git clone开始，也就是创造了一个本地分支，从远端仓库复制过来，经过本地的修改，然后推送回去 git push就是合并了。 正文在这里我们想象 每次的提交的时候，Git 就像把他们串成一条时间线。刚开始的时候，只有一条时间线也叫做主分支，master分支。head是指向的是当前分支。每次提交，master分支都会前进一步，后面则是越来越长。当我们创建新分支例如dev时候，就有新建了一条线。然后修改了head的指向。现在，对dev的修改和提交都不会对master影响，没次提交dev节点就往前一步。加入dev完成，就可以合并到master上，同时head指会master 示例以上述为例，首先，创建dev分支，然后切换到dev分支 1git checkout -b dev 这里相当于两条命令，-b 表示创建并切换。 12git branch devgit checkout dev 通过git branch查看当前分支 123$ git branch *dev master 如果是当前分支，前面会标记*号。后面也就是对分支的正常惯例提交方式（这里假设我添加了 test.txt） 123$ git add test.txt$ git commit -m &quot;add test.txt&quot;$ git push origin dev 切换到master上，我们查看一些没看到test.txt文件，因为那是在dev分支上，现在我们进行合并。 1$ git merge dev 这里的git merge使用于合并指定分支到当前分支。 常用指令 查看分支：git branch创建分支：git branch (name)切换分支：git checkout (name)创建和切换分支：git checkout -b (name)合并某个分支到当前分支：git merger (name)删除分支：git branch -d (name)]]></content>
      <categories>
        <category>Git Bash</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo博客的备份和迁移管理]]></title>
    <url>%2Fhexo%E5%8D%9A%E5%AE%A2%E7%9A%84%E5%A4%87%E4%BB%BD%E5%92%8C%E8%BF%81%E7%A7%BB%E7%AE%A1%E7%90%86.html</url>
    <content type="text"><![CDATA[前言我们都知道，我们刚开始的博客比如hexo，是编译后上去的静态网页文件。我们的文章啊等等都在本地，但是如果我们换了电脑怎么办，放在U盘复制过去也不是不行。但是如果电脑死机等不定因素不能复制等，不得凉凉了。这个时候我们可以借用 GitHub 来备份源文件了。我们知道 GitHub 是能建立分支的。所以我们利用它在我们的博客仓库建立一个分支来保存源文件。 正文建立一个中转站 我们先建立一个文件夹，名字随便，我这里叫hexo，在这里启动 GitBash ,先克隆我们的仓库 git clone https://github.com/Witman1999/Witman1999.github.io.git之后就复制了我们仓库编译后的静态网页文件。 这里其实是为了获得版本管理的 .git 建立分支这里建立分支,我这里分支名为 hexo ，输入代码git checkout -b hexo之后就建立了一个 hexo 分支 清空 hexo 分支 这里我们都知道，我们这里只要保存源文件，不需要那些编译后的静态网页。所以要清空。 我们删除除了 .git 文件夹之外的文件或文件夹。在删除后通过代码 git status 查看到然后保存到带添加列表： git add --all ,这里是代表添加了所有，后面提交到本地仓库git commit -m &quot;清空hexo分支仓库&quot;，-m 后面的提交信息可以自定义。最后我们推送到远端更新git push --set-upstream origin hexo 这里同时设置了以后默认为hexo分支，回到博客的根目录下就能看到。 后面红线标注的就是当前的分支。 查看文件，这里我们的博客的站点配置文件 _config.yml 的默认提交分支要确保为 master 1234deploy: type: git repo: https://github.com/Witman1999/Witman1999.github.io.git branch: master #提交的默认分支 移动文件把 .git 文件夹移动到博客的根目录下 提交源文件 这里的主题文件，在 themes/ 文件夹下，有些是克隆 Github 下来的，有着 Github 的 .git版本管理文件，这里要删除 .git文件夹和 .gitignore 文件，不然会忽略这个 next 主题 然后安装更新 Github 的仓库的步骤，在博客的根目录下，输入 git add --all git commit -m “提交源文件” git push （这里要确保提交的分支为 hexo ，在前面的步骤可以查看，如果不是可以输入 git checkout hexo切换分支）]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[next新版本自定义样式（hexo）]]></title>
    <url>%2Fnext%E6%96%B0%E7%89%88%E6%9C%AC%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A0%B7%E5%BC%8F.html</url>
    <content type="text"><![CDATA[更新到最新版的 next主题我们发现自定义的 css 样式位置发生了改变。 第一步打开主题配置文件 1234567891011custom_file_path: # head: source/_data/head.swig #header: source/_data/header.swig #sidebar: source/_data/sidebar.swig #postMeta: source/_data/post-meta.swig #postBodyEnd: source/_data/post-body-end.swig #footer: source/_data/footer.swig #bodyEnd: source/_data/body-end.swig #variable: source/_data/variables.styl #mixin: source/_data/mixins.styl #style: source/_data/custom.styl 发现了这段代码，我们把style: source/_data/custom.styl取消注释 第二部在博客的根目录下创建文件,路径为myblog/source/_data/custom.styl这里其实发现只要和主题配置文件的路径一致就行，文件名可以自己更改。然后在里面就可以写自定义样式了。]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用 Git 删除本地仓库和远端仓库文件]]></title>
    <url>%2F%E4%BD%BF%E7%94%A8%20Git%20%20%E5%88%A0%E9%99%A4%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%E5%92%8C%E8%BF%9C%E7%AB%AF%E4%BB%93%E5%BA%93%E6%96%87%E4%BB%B6.html</url>
    <content type="text"><![CDATA[使用 git bash 来删除 一、将文件（夹）添加到暂存区这里假设本地和远端都有一个 test.txt 文件先在本地删除，通过 ·git status 查看通过git add test.txt 添加到暂存区 二、更新本地仓库执行git commit -m &quot;删除test.txt&quot; 其中-m 后面的信息是用来说明的。 三、更新 GitHub 的仓库执行 git push origin master之后我们查看 github 的仓库就消失了 其他例如更新、添加操作都类似。]]></content>
      <categories>
        <category>Git Bash</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git本地仓库关联远端仓库以及上传]]></title>
    <url>%2F%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%E5%85%B3%E8%81%94%E8%BF%9C%E7%AB%AF%E4%BB%93%E5%BA%93%E4%BB%A5%E5%8F%8A%E4%B8%8A%E4%BC%A0.html</url>
    <content type="text"><![CDATA[一、建立 git 本地仓库新建一个本地仓库，相当于就是建立一个新的文件夹，然后在该文件夹下右键点击 Git Bash Here，之后输入命令 git init 初始化（我这里用``hexo-theme-next`文件夹展示） 二、添加东西到本地仓库首先将需要上传的东西复制到这个文件夹下，然后通过 git status 查看发现有红色的就是等待添加到本地仓库的东西。 2.1 将文件（文件夹）添加到本地仓库中如何添加呢？首先 git add ( 需要添加的文件名 ) 或者 git add --all（添加所有的文件夹），这里我是通过 git add --all 添加的之后通过 git status 查看状态都变成了绿色，这个步骤是添加到待上传的列表中 2.2 将文件提交到本地仓库之后把待上传的列表中文件（夹），通过 git commit -m &quot;提交说明&quot;。-m后面添加的是对本次操作的说明，修改了代码，重新上传或者删除了什么东西都做个简单说明。 三、在 GitHub 创建自己的仓库通过 create repository 创建一个仓库，然后拿到 https 的地址 四、本地仓库关联 GitHub通过 git remote add origin url 这里 url 就是在第三步自己创建仓库拿到的地址（也可以是早就以及创建好的仓库，这步操作能用了关联远端） 五、上传到 GitHub通过git push -u origin master git push &lt;远程主机名&gt; &lt;远程分支名&gt; 把当前提交到git本地仓库的代码推送到远程主机的某个远程分之上 注意！中间可能会让你输入Username和Password。在这一步很多人执行会报错，报类似failed to push some refs to……的错误，这是因为本地代码目录缺失README.md文件。我们只需要先通过以下代码和本地同步，合并。git pull --rebase origin master执行后，会把远端的文件克隆下来本地]]></content>
      <categories>
        <category>Git Bash</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决hexo引用网络图片显示错误的问题]]></title>
    <url>%2F%E8%A7%A3%E5%86%B3Hexo%E5%BC%95%E7%94%A8%E7%BD%91%E7%BB%9C%E5%9B%BE%E7%89%87%E6%98%BE%E7%A4%BA%E9%94%99%E8%AF%AF%E7%9A%84%E9%97%AE%E9%A2%98.html</url>
    <content type="text"><![CDATA[问题博文在本地写好，打开 localhost::4000 显示还是好的，hexo d 之后还能显示，但是过几天显示不了如图： 解决方法打开 myblog/themes/next/layout/_partials 文件夹下的 head.swig 添加如下的代码：&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[测试评论]]></title>
    <url>%2F%E6%B5%8B%E8%AF%95%E8%AF%84%E8%AE%BA.html</url>
    <content type="text"><![CDATA[类名首字母要大写，如果类名由几个单词构成，把么把它们拼接在一起（也就是说，不要用下划线来分隔名字），其中每个内部首字母都采用大写 方法，字段（成语变量）以及对象引用名称等，公认的风格与类的风格一样，只是标识符的第一个字母小写]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客美化]]></title>
    <url>%2F%E5%8D%9A%E5%AE%A2%E7%BE%8E%E5%8C%96.html</url>
    <content type="text"><![CDATA[1. 更改主题 通过网络下载主题 将解压后的文件存到（我的本地博客文件夹为 myblog） myblog/themes/ 下 打开主题配置文件 myblog/config.yml 找到以下代码1theme: landscape 修改成： 12theme: name# name 就是你解压后的文件夹名字 2. 更改主题样式（以 nextT 为例子） 打开 themes/next/config.yml 文件（主题配置文件） 找到如下代码12345# Schemesscheme: Muse#scheme: Mist#scheme: Pisces#scheme: Gemini 有四种，只要将当前的样式（前面没 # 号的）屏蔽，也就是前面加个 # 号，要选择的删除掉 # 字符就行。 3. 增加侧边栏选项打开主题配置文件 themes/next/config.yml 找到如下代码： 123456789menu: home: / || home about: /about/ || user tags: /tags/ || tags categories: /categories/ || th archives: /archives/ || archive #schedule: /schedule/ || calendar #sitemap: /sitemap.xml || sitemap #commonweal: /404/ || heartbeat 想要的取消屏蔽就行 4. 更改语言打开站点配置文件 config.yml找到对应的代码： 12345678# Sitetitle: 不忘什么心？subtitle: 努力的，都将以另一种方式呈现。description: 努力的，都将以另一种方式呈现keywords:author: 志者language: zh-Hanstimezone: 修改对应的 language 字段 5. 首页显示文章的部分打开主题配置文件 themes/next/config.yml ，找到代码修改 1234auto_excerpt: enable: true length: 280# length 为长度 6. 开启图标如图：打开主题配置文件 themes/next/config.yml 1234567891011social: GitHub: https://github.com/yourname || github E-Mail: mailto:yourname@gmail.com || envelope Google: https://plus.google.com/yourname || google Twitter: https://twitter.com/yourname || twitter #FB Page: https://www.facebook.com/yourname || facebook #VK Group: https://vk.com/yourname || vk #StackOverflow: https://stackoverflow.com/yourname || stack-overflow #YouTube: https://youtube.com/yourname || youtube #Instagram: https://instagram.com/yourname || instagram #Skype: skype:yourname?call|chat || skype 取消屏蔽就行 7 点击头像回到博客首页 把头像avatar.gif放在~/blog/source/uploads/下，则：12345修改主题配置文件，位置：~/myblog/themes/next/_config.yml# Sidebar Avatar# in theme directory(source/images): /images/avatar.gif# in site directory(source/uploads): /uploads/avatar.gifavatar: /uploads/avatar.gif 然后编辑文件： 123456修改文件，位置：~/blog/themes/next/layout/_macro/sidebar.swig &lt;a href=&quot;/&quot;&gt; &lt;img class=&quot;site-author-image&quot; itemprop=&quot;image&quot; src=&quot;&#123;&#123; url_for( theme.avatar | default(theme.images + &apos;/avatar.gif&apos;) ) &#125;&#125;&quot; alt=&quot;&#123;&#123; theme.author &#125;&#125;&quot; /&gt; &lt;/a&gt; 8. 移动端显示 back-to-top 按钮和侧栏123# 文件位置：~/blog/themes/next/_config.yml# Enable sidebar on narrow viewonmobile: true 9. 更改标签云的颜色文件位置：~/blog/themes/next/layout/page.swig 1&#123;&#123; tagcloud(&#123;min_font: 13, max_font: 31, amount: 1000, color: true, start_color: &apos;#9733EE&apos;, end_color: &apos;#FF512F&apos;&#125;) &#125;&#125; 修改对应参数值即可，参数说明见 Hexo 官方文档，颜色可以参考这个网站，自己去纠结…… 10. 修改文章底部的那个带#号的标签实现效果图具体实现方法修改模板 /themes/next/layout/_macro/post.swig，搜索 rel=&quot;tag&quot;&gt;#，将 # 换成 &lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt; 11. 在每篇文章末尾统一添加“本文结束”标记实现效果图具体实现方法在路径 \themes\next\layout_macro 中新建 passage-end-tag.swig 文件,并添加以下内容： 12345&lt;div&gt; &#123;% if not is_index %&#125; &lt;div style="text-align:center;color: #ccc;font-size:14px;"&gt;-------------本文结束&lt;i class="fa fa-paw"&gt;&lt;/i&gt;感谢您的阅读-------------&lt;/div&gt; &#123;% endif %&#125;&lt;/div&gt; 接着打开 \themes\next\layout\_macro\post.swig 文件，在 post-body 之后， post-footer 之前添加如下画红色部分代码（post-footer之前两个DIV）：代码如下： 12345&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include &apos;passage-end-tag.swig&apos; %&#125; &#123;% endif %&#125;&lt;/div&gt; 然后打开主题配置文件 （_config.yml),在末尾添加： 123# 文章末尾添加“本文结束”标记passage_end_tag: enabled: true 11. 修改``代码块自定义样式实现效果图具体实现方法打开 \themes\next\source\css\_custom\custom.styl ,向里面加入：(颜色可以自己定义) 123456789101112131415// Custom styles.code &#123; color: #ff7600; background: #fbf7f8; margin: 2px;&#125;// 大代码块的自定义样式.highlight, pre &#123; margin: 5px 0; padding: 5px; border-radius: 3px;&#125;.highlight, code, pre &#123; border: 1px solid #d6d6d6;&#125; 12. 侧边栏社交小图标设置实现效果图实现方法打开主题配置文件（_config.yml），搜索social:,在图标库找自己喜欢的小图标，并将名字复制在如下位置，保存即可 13. 网站底部字数统计实现效果图具体实现方法切换到根目录下，然后运行如下代码npm install hexo-wordcount --save然后在/themes/next/layout/_partials/footer.swig文件尾部加上： 1234&lt;div class=&quot;theme-info&quot;&gt; &lt;div class=&quot;powered-by&quot;&gt;&lt;/div&gt; &lt;span class=&quot;post-count&quot;&gt;博客全站共&#123;&#123; totalcount(site) &#125;&#125;字&lt;/span&gt;&lt;/div&gt; 14. 添加“404”页面腾讯公益404页面，寻找丢失儿童，让大家一起关注此项公益事业！效果如下 http://www.ixirong.com/404.html， 使用方法，新建 404.html 页面，放到主题的 source 目录下，内容如下： 1234567891011121314151617&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv="content-type" content="text/html;charset=utf-8;"/&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" /&gt; &lt;meta name="robots" content="all" /&gt; &lt;meta name="robots" content="index,follow"/&gt;&lt;/head&gt;&lt;body&gt;&lt;script type="text/javascript" src="http://www.qq.com/404/search_children.js" charset="utf-8" homePageUrl="your site url " homePageName="回到我的主页"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 15. 文章置顶首先移除默认安装的插件：npm uninstall hexo-generator-index --save然后安装新插件：npm install hexo-generator-index-pin-top --save最后编辑有这需求的相关文章时，在 Front-matter（文件最上方以 — 分隔的区域）加上一行：top: true然后就行了。如果你置顶了多篇，怎么控制顺序呢？设置 top 的值（大的在前面），比如： 123# Post a.mdtitle: atop: 1 可是，没有任何标记啊，读者怎么知道文章置顶了,编辑文件： 123456789101112131415161718192021222324252627282930// 文件位置：~/blog/node_modules/hexo-generator-index-pin-top/lib/generator.js'use strict';var pagination = require('hexo-pagination');module.exports = function(locals)&#123; var config = this.config; var posts = locals.posts; posts.data = posts.data.sort(function(a, b) &#123; if(a.sticky &amp;&amp; b.sticky) &#123; // 两篇文章sticky都有定义 if(a.sticky == b.sticky) return b.date - a.date; // 若sticky值一样则按照文章日期降序排 else return b.sticky - a.sticky; // 否则按照sticky值降序排 &#125; else if(a.sticky &amp;&amp; !b.sticky) &#123; // 以下是只有一篇文章sticky有定义，那么将有sticky的排在前面（这里用异或操作居然不行233） return -1; &#125; else if(!a.sticky &amp;&amp; b.sticky) &#123; return 1; &#125; else return b.date - a.date; // 都没定义按照文章日期降序排 &#125;); var paginationDir = config.pagination_dir || 'page'; return pagination('', posts, &#123; perPage: config.index_generator.per_page, layout: ['index', 'archive'], format: paginationDir + '/%d/', data: &#123; __index: true &#125; &#125;);&#125;; 也就是将 top 全部替换为 NexT 原有的 sticky，然后将 Front-matter 中的 top 替换为 sticky。 最后可以自定义一下样式： 123456789101112131415/* 文件位置：~/blog/themes/next/source/css/_custom/custom.styl *//* 自定义的文章置顶样式 */.post-sticky-flag &#123; font-size: inherit; float: left; color: rgb(0, 0, 0); cursor: help; transition-duration: 0.2s; transition-timing-function: ease-in-out; transition-delay: 0s;&#125;.post-sticky-flag:hover &#123; color: #07b39b;&#125; 16. 建立模板文件如果你是在站点文件夹根目录用 hexo new post &lt;title&gt; 新建的文章，那么其实它就是将文章的模版文件 post.md「复制」了一份到 ~/myblog/source/_posts/ 下，所以这也意味着： 你可以直接通过在 ~/blog/source/_posts/ 下新建.md 结尾的文件来写新的文章。 你可以通过自定义文章的模版文件，从而每次命令行新建的文章都会有你自定义的内容。 如果自己直接新建文件，一定要记得加上文件最上方的参数，即下面的相关内容，还有编码请用 UTF-8。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677# ！！！！！！！！！！# 每一项的 : 后面均有一个空格# 且 : 为英文符号# ！！！！！！！！！！title:# 文章标题，可以为中文date:# 建立日期，如果自己手动添加，请按固定格式updated:# 更新日期，其它与上面的建立日期类似permalink:# 若站点配置文件下的 permalink 配置了 title# 则可以替换文章 URL 里面的 title（文章标题）categories:# 分类，支持多级，比如：tags:# 标签# 多个可以这样写 [标签1,标签2,标签3]description:# 文章的描述，在每篇文章标题下方显示# 并且作为网页的 description 元数据# 如果不写，则自动取 &lt;!-- more --&gt;# 之前的文字作为网页的 description 元数据keywords:# 关键字，并且作为网页的 keywords 元数据# 如果不写，则自动取 tags 里的项comments:# 是否开启评论# 默认值是 true# 要关闭写 falselayout:# 页面布局，默认值是 post，默认值可以在# 站点配置文件中修改 default_layout# 另：404 页面可能用到，将其值改为 falsetype:# categories，目录页面# tags，标签页面# picture，用来生成 group-pictures# quote？# https://io-oi.me/tech/test/photos:# Gallery support，用来支持画廊╱相册，用法如下：# - photo_url_1# - photo_url_2# - photo_url_3# https://io-oi.me/tech/test/link:# 文章的外部链接# https://io-oi.me/tech/test/image:# 自定义的文章摘要图片，只在页面展示，文章内消失# 先配置好，否则请勿添加！sticky:# 文章置顶# 先配置好，否则请勿添加！password:# 文章密码，此项只有参考教程：# http://shenzekun.cn/hexo的next主题个性化配置教程.html# 第 24 节，配置好，否则请勿添加！# 发现还是有 bug 的，就是右键在新标签中打开# 然后无论是否输入密码，都能看到内容 附加：如果要应用多个类别层次结构，请使用名称列表而不是单个名称。如果Hexo在帖子上看到以这种方式定义的任何类别，它会将该帖子的每个类别视为其自己的独立层次结构。 12345categories:- [Sports, Baseball]- [MLB, American League, Boston Red Sox]- [MLB, American League, New York Yankees]- Rivalries 17. 文章图片文章摘要（excerpt）是指每篇文章（post）在页面（page）上显示的那部分内容，[Read More] 之前的文章内容。由于它会展示在页面，因此在每篇文章的文章摘要中加一张图片。但会出现你想从文章中选一张图片作为文章摘要图片，而这张图片由于写作要求，必须添加在文章的末尾，这样点 [Read More] 查看文章时，这张图片就会重复出现了。咋办？ 前提是在主题配置文件中： 123456# 文件位置：~/blog/themes/next/_config.ymlexcerpt_description: falseauto_excerpt: enable: false 首先加代码： 12345678910111213141516171819202122232425262728&lt;!-- 文件位置：~/blog/themes/next/layout/_macro/post.swig --&gt; &#123;% if is_index %&#125; &#123;% if post.description and theme.excerpt_description %&#125; &#123;&#123; post.description &#125;&#125; &lt;!--noindex--&gt; &lt;div class="post-button text-center"&gt; &lt;a class="btn" href="&#123;&#123; url_for(post.path) &#125;&#125;"&gt; &#123;&#123; __('post.read_more') &#125;&#125; &amp;raquo; &lt;/a&gt; &lt;/div&gt; &lt;!--/noindex--&gt; &#123;% elif post.excerpt %&#125; &#123;&#123; post.excerpt &#125;&#125;+ + &#123;% if post.image %&#125;+ &lt;div class="out-img-topic"&gt;+ &lt;img src=&#123;&#123; post.image &#125;&#125; class="img-topic" /&gt;+ &lt;/div&gt;+ &#123;% endif %&#125;+ &lt;!--noindex--&gt; &lt;div class="post-button text-center"&gt; &lt;a class="btn" href="&#123;&#123; url_for(post.path) &#125;&#125;&#123;% if theme.scroll_to_more %&#125;#&#123;&#123; __('post.more') &#125;&#125;&#123;% endif %&#125;" rel="contents"&gt; &#123;&#123; __('post.read_more') &#125;&#125; &amp;raquo; &lt;/a&gt; &lt;/div&gt; &lt;!--/noindex--&gt; 为了防止有的图片宽度不够导致风格不够统一，页面不美观，需要在 custom.styl 中加入： 123456/* 文件位置：~/blog/themes/next/source/css/_custom/custom.styl *//* 自定义的文章摘要图片样式 */img.img-topic &#123; width: 100%;&#125; 最后编辑有这需求的相关文章时，在 Front-matter（文件最上方以 — 分隔的区域）加上一行：image: url参考：这里 18. 添加评论效果图首先在_config.yml文件添加如下配置 123# Support for LiveRe comments system.# You can get your uid from https://livere.com/insight/myCode (General web site)livere_uid: your uid 其中your uid在来必力注册获得，注册完后点击右上角如图：在这里放上自己的博客网站，之后点击认证就可以获取安装代码（City版），然后代码中的data-uid就是your uid然后在 layout/_scripts/third-party/comments/ 目录中添加 livere.swig，文件内容如下： 1234567891011121314&#123;% if not (theme.duoshuo and theme.duoshuo.shortname) and not theme.duoshuo_shortname and not theme.disqus_shortname and not theme.hypercomments_id and not theme.gentie_productKey %&#125; &#123;% if theme.livere_uid %&#125; &lt;script type="text/javascript"&gt; (function(d, s) &#123; var j, e = d.getElementsByTagName(s)[0]; if (typeof LivereTower === 'function') &#123; return; &#125; j = d.createElement(s); j.src = 'https://cdn-city.livere.com/js/embed.dist.js'; j.async = true; e.parentNode.insertBefore(j, e); &#125;)(document, 'script'); &lt;/script&gt; &#123;% endif %&#125;&#123;% endif %&#125; 然后在 layout/_scripts/third-party/comments.swig文件中追加： 1&#123;% include './comments/livere.swig' %&#125; 最后，在 ``layout/_partials/comments.swig `文件中条件最后追加 LiveRe 插件是否引用的判断逻辑： 123&#123;% elseif theme.livere_uid %&#125; &lt;div id="lv-container" data-id="city" data-uid="&#123;&#123; theme.livere_uid &#125;&#125;"&gt;&lt;/div&gt;&#123;% endif %&#125; 参考：这里 19. 文章底部添加版权信息在目录 next/layout/_macro/下添加 my-copyright.swig 123456789101112131415161718192021222324252627282930&#123;% if page.copyright %&#125;&lt;div class="my_post_copyright"&gt; &lt;script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"&gt;&lt;/script&gt; &lt;!-- JS库 sweetalert 可修改路径 --&gt; &lt;script src="https://cdn.bootcss.com/jquery/2.0.0/jquery.min.js"&gt;&lt;/script&gt; &lt;script src="https://unpkg.com/sweetalert/dist/sweetalert.min.js"&gt;&lt;/script&gt; &lt;p&gt;&lt;span&gt;本文标题:&lt;/span&gt;&lt;a href="&#123;&#123; url_for(page.path) &#125;&#125;"&gt;&#123;&#123; page.title &#125;&#125;&lt;/a&gt;&lt;/p&gt; &lt;p&gt;&lt;span&gt;文章作者:&lt;/span&gt;&lt;a href="/" title="访问 &#123;&#123; theme.author &#125;&#125; 的个人博客"&gt;&#123;&#123; theme.author &#125;&#125;&lt;/a&gt;&lt;/p&gt; &lt;p&gt;&lt;span&gt;发布时间:&lt;/span&gt;&#123;&#123; page.date.format("YYYY年MM月DD日 - HH:mm") &#125;&#125;&lt;/p&gt; &lt;p&gt;&lt;span&gt;最后更新:&lt;/span&gt;&#123;&#123; page.updated.format("YYYY年MM月DD日 - HH:mm") &#125;&#125;&lt;/p&gt; &lt;p&gt;&lt;span&gt;原始链接:&lt;/span&gt;&lt;a href="&#123;&#123; url_for(page.path) &#125;&#125;" title="&#123;&#123; page.title &#125;&#125;"&gt;&#123;&#123; page.permalink &#125;&#125;&lt;/a&gt; &lt;span class="copy-path" title="点击复制文章链接"&gt;&lt;i class="fa fa-clipboard" data-clipboard-text="&#123;&#123; page.permalink &#125;&#125;" aria-label="复制成功！"&gt;&lt;/i&gt;&lt;/span&gt; &lt;/p&gt; &lt;p&gt;&lt;span&gt;许可协议:&lt;/span&gt;&lt;i class="fa fa-creative-commons"&gt;&lt;/i&gt; &lt;a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" title="Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)"&gt;署名-非商业性使用-禁止演绎 4.0 国际&lt;/a&gt; 转载请保留原文链接及作者。&lt;/p&gt; &lt;/div&gt;&lt;script&gt; var clipboard = new Clipboard('.fa-clipboard'); $(".fa-clipboard").click(function()&#123; clipboard.on('success', function()&#123; swal(&#123; title: "", text: '复制成功', icon: "success", showConfirmButton: true &#125;); &#125;); &#125;); &lt;/script&gt;&#123;% endif %&#125; 在目录next/source/css/_common/components/post/`下添加`my-post-copyright.styl 123456789101112131415161718192021222324252627282930313233343536373839404142434445.my_post_copyright &#123; width: 85%; max-width: 45em; margin: 2.8em auto 0; padding: 0.5em 1.0em; border: 1px solid #d3d3d3; font-size: 0.93rem; line-height: 1.6em; word-break: break-all; background: rgba(255,255,255,0.4);&#125;.my_post_copyright p&#123;margin:0;&#125;.my_post_copyright span &#123; display: inline-block; width: 5.2em; color: #b5b5b5; font-weight: bold;&#125;.my_post_copyright .raw &#123; margin-left: 1em; width: 5em;&#125;.my_post_copyright a &#123; color: #808080; border-bottom:0;&#125;.my_post_copyright a:hover &#123; color: #a3d2a3; text-decoration: underline;&#125;.my_post_copyright:hover .fa-clipboard &#123; color: #000;&#125;.my_post_copyright .post-url:hover &#123; font-weight: normal;&#125;.my_post_copyright .copy-path &#123; margin-left: 1em; width: 1em; +mobile()&#123;display:none;&#125;&#125;.my_post_copyright .copy-path:hover &#123; color: #808080; cursor: pointer;&#125; 修改next/layout/_macro/post.swig，在代码 12345&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include 'wechat-subscriber.swig' %&#125; &#123;% endif %&#125;&lt;/div&gt; 之前添加增加如下代码： 12345&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include 'my-copyright.swig' %&#125; &#123;% endif %&#125;&lt;/div&gt; 修改next/source/css/_common/components/post/post.styl文件，在最后一行增加代码：@import &quot;my-post-copyright&quot;保存重新生成即可。如果要在该博文下面增加版权信息的显示，需要在 Markdown 中增加copyright: true的设置，类似： 20 代码块添加复制功能 在新版本的 next7.3 下已经内置了复制按钮，在主题配置文件设置即可，且提供不同主题风格（default / flat / mac）进行选择。。 123456copy_button: enable: true # Show text copy result. show_result: false # Available values: default | flat | mac style: mac 参考博客以上皆为参考别人博客记录，下面一一列出。 打造个性超赞博客 Hexo + NexT + GitHub Pages的超深度优化 【搜索优化】Hexo-next百度和谷歌搜索优化 Hexo 个人博客 SEO 优化（3）：改造你的博客，提升搜索引擎排名 Hexo博客Next主题SEO优化方法 白衣秀才 博采众长 hexo史上最全搭建教程]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建博客（hexo）]]></title>
    <url>%2F%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%EF%BC%88hexo%EF%BC%89.html</url>
    <content type="text"><![CDATA[一. 下载 nodejs点击 node.js 官网，就可以进行下载，例如下图： 安装之后，打开终端(win+R)，输入 cmd,之后在终端输入： 12node -vnpm -v 结果如图： 二 安装 hexo终端输入1npm install -g hexo-cli 验证在终端输入 1hexo -v 结果如图： 三 搭建 建立一个空文件夹，名字任意（我的为 myblog） 以后出错直接将该文件夹删掉重来就行 终端进入 myblog 文件夹 初始化博客，终端输入 hexo init 启动博客查看 hexo server(按 ctrl+c 停止服务) 浏览器输入 localhost::4000 新建文章 hexo new post “我的第一篇文章” 生成 hexo clean（清空） hexo g（配置） hexo s（开启服务）四. 部署到 GitHub 创建个人账户 在 GitHub 创建仓库 注意：用户部署个人博客的 GitHub 仓库的命名必须和 GitHub 用户名（昵称）一样 装 git 插件 终端输入： npm install -save hexo-deployer-git 修改 myblog 文件夹下的 config.yml（站点配置文件） 拉到底部看到 deploy 改成12345deploy: type: git repo: https://github.com/yourname/yourname.github.io.git branch: master# 其中yourname是你 GitHub 用户名（记住，仓库名必须和 GitHub 用户名一样） 部署远端 终端输入：hexo d五 更换主题以 nextT 主题为例子 下载的主题文件放到 myblog/themes/ 在 myblog 文件夹下，修改 config.yml（站点配置文件）找到如下代码 1234# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: landscape 改成 1theme: next 参考博客 Github+Hexo+NextT搭建个人博客 Hexo框架+NextT主题搭建博客教程(部署到coding net) hexo史上最全搭建教程]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原码，反码，补码]]></title>
    <url>%2F%E5%8E%9F%E7%A0%81%EF%BC%8C%E5%8F%8D%E7%A0%81%EF%BC%8C%E8%A1%A5%E7%A0%81.html</url>
    <content type="text"><![CDATA[原码 最简单的机器数表示法，最高位表示符号位，“ 1 ”表示符号，“0”表示正号。其他位存放该数的二进制的绝对值 若以带符号位的四位二进制数为例子 123451010 ： 最高位为‘1’,表示这是一个负数，其他三位为‘010’， 即（0*2^2）+（1*2^1）+（0*2^0）=2（‘^’表示幂运算符） 所以1010表示十进制数（-2）。 补码用于解决减法运算因为原码的最大问题在于一个数加上他的相反数不等于0，所以，既然一个负数是一个整数的相反数，那我们把那个负数转化为正数，按位取反，来表示这个负数 正数的反码还是等于原码负数的反码就是他的原码除符号位外，按位取反 1234563是正数，反码与原码相同，则可以表示为0011-3的原码是1011，符号位保持不变，低三位（011）按位取反得（100）所以-3的反码为1100 补码用于解决符号问题 正数的补码等于他的原码负数的补码等于反码+1 我们再次强调原码，反码，补码的引入是为了解决做减法的问题。在原码，反码表示法中，我们把减法化为加法的思维是减去一个数，等于加上一个数的相反数，结果发现引入了符号位，却因为符号位造成了各种意向不到的问题。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串和数字转换]]></title>
    <url>%2F%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%8E%E6%95%B0%E5%AD%97%E8%BD%AC%E6%8D%A2.html</url>
    <content type="text"><![CDATA[12345678910111213public class Test &#123; public static void main(String[] args) &#123; String str = "123"; Integer num1 = new Integer(str); int num2 = Integer.parseInt(str); Integer num3 = Integer.valueOf(str); System.out.println(num1 + "\t" + num2 + "\t" + num3);//123 123 123 &#125;&#125; 在上面代码中，演示了三个方式的转化，分别是new了新对象和调用静态方法，我们查看内部的变化 Interger 类的构造函数123public Integer(String s) throws NumberFormatException &#123; this.value = parseInt(s, 10); &#125; 从代码中看的，构造函数时调用了一个parseInt(s,10)的内部函数 parseInt(s)123public static int parseInt(String s) throws NumberFormatException &#123; return parseInt(s,10); &#125; 从代码中看到也是调用了一个parseInt(s,10)的内部函数 Integer.valueOf(s)123public static Integer valueOf(String s) throws NumberFormatException &#123; return Integer.valueOf(parseInt(s, 10)); &#125; 从代码中看到也是调用了一个&ensp;parseInt(s,10)&ensp;的内部函数我们可以看出其实都调用了&ensp;parseInt(String s,int radix);&ensp;让我们看看他内部实现 parseInt(String s,int radix)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public static int parseInt(String s, int radix) throws NumberFormatException &#123; /* * WARNING: This method may be invoked early during VM initialization * before IntegerCache is initialized. Care must be taken to not use * the valueOf method. */ if (s == null) &#123; throw new NumberFormatException("null"); &#125; if (radix &lt; Character.MIN_RADIX) &#123; throw new NumberFormatException("radix " + radix + " less than Character.MIN_RADIX"); &#125; if (radix &gt; Character.MAX_RADIX) &#123; throw new NumberFormatException("radix " + radix + " greater than Character.MAX_RADIX"); &#125; int result = 0; boolean negative = false; int i = 0, len = s.length(); int limit = -Integer.MAX_VALUE; int multmin; int digit; if (len &gt; 0) &#123; char firstChar = s.charAt(0); if (firstChar &lt; '0') &#123; // Possible leading "+" or "-" if (firstChar == '-') &#123; negative = true; limit = Integer.MIN_VALUE; &#125; else if (firstChar != '+') throw NumberFormatException.forInputString(s); if (len == 1) // Cannot have lone "+" or "-" throw NumberFormatException.forInputString(s); i++; &#125; ...... ...... ...... &#125; else &#123; throw NumberFormatException.forInputString(s); &#125; return negative ? result : -result; &#125; 从代码中看出，==字符串不能为空值以及字符串得为数字==，不然会报异常（&ensp;NumberFormatException&ensp;）]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>example</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线程]]></title>
    <url>%2F%E7%BA%BF%E7%A8%8B.html</url>
    <content type="text"><![CDATA[进程与线程进程是程序运行的基本单位，一个程序就是代表一个进程，进程与进程之间是相互独立的，它们是由 CPU 进行调度的（分配内存空间） ，由于它们是相互独立所以各自的资源不共享。一台电脑中可以运行多个程序，并且执行效率快，所以它是高效而且并发性的。在一个时间段中，可以执行多个进程（程序），一个进程是非常占内存空间的，对 CPU 的开销也是非常大的。 线程是程序流中最小的执行单位，一个程序中至少存在一个线程，线程占空间内存是非常少的，一个进程中多个线程资源是可以共享的。线程消耗的内存少执行效率高，同一时间段中可以执行多个线程，线程具有并发性的特点。（线程调度：（分时间）轮询调度和抢占式调度），资源共享；注意的是资源是否会丢失（安全）。 区别 一个程序至少有一个进程，一个进程至少有一个线程 线程的划分尺度小于进程，使得多线程程序的并发性高。 进程有独立的内存单元，而多个线程共享内存 线程必须依靠存在于应用程序中 多线程实在程序中多个部分同时执行，但是系统并没有把多个线程当场多个独立的应用，来实现进程的调度和管理资源分配。 线程开销小，不利于资源的管理和保护，进程正好相反。 线程数据共享 线程的实现java 中一共有两种方式实现线程 继承 Thread 类通过继承 java.lang.Thread 类来实现线程： 1234567891011public class MyThread extends Thread&#123; @Override public void run()&#123; ..... &#125; &#125;public static void main(String[] args)&#123; MyThread mt = new MyThread(); mt.start();&#125; 继承 Thread 类是之后要实现 run() 方法，线程启动之后是执行 run() 方法。之后调用 Thread 的 start 的方法就能开启线程( 同一对象不能调用同一 start() 方法) 实现 Runnable 接口，并且 start() 内部类实现123456789101112131415161718192021222324252627new Thread(new Runnable()&#123; @Override public void run() &#123; int i=0; i++; System.out.println(i); &#125;&#125;).start();``` 2. 另写一个类实现接口```javaclass myRunnable implement Runnable&#123; @Override public void run() &#123; int i=0; i++; System.out.println(i); &#125;&#125;public static void main(String[] args)&#123; myRunnable mr = new myRunnable(); Thread t1 = new Thread(mr); t1.start();&#125; 生命周期 状态包括 出生状态，就绪状态，运行状态，等待状态，休眠状态，阻塞状态，死亡状态。 在用户 new 出来的时候为“出生状态”；此时当用户调用 start() 的时候处于“就绪状态”；当线程得到资源后进入“运行状态”；当运行时调用 wait() 方法时线程处于 “等待状态”，此时必须从其他线程调用 notify() 方法才能唤醒，notifyAll() 可以除了调用这个线程以外所有处于等待状态下的线程；当线程调用 sleep() 方法时会进入 “休眠状态”，结束后进入就绪；如果一个线程在运行状态下发出输入/输出（Sacnner）请求，该线程将进入阻塞状态，输入/输出结束时线程进入就绪 状态；当线程的 run() 方法执行完毕/异常/stop() 时线程进入“死亡状态” 线程常用方法1. 线程的休眠（ sleep ）静态方法，最后不要用 Thread 对象调用它，因为它睡眠的始终是当前正在运行的线程，不是调用它的线程对象，只对正在运行状态的线程对象有效。单位 ms 通常使得线程释放当前 cpu 执行权，苏醒后并不一定时运行状态，只能保证他进入就绪状态。 12345try&#123; Thread.sleep(1000);&#125;catch(InterruptedException e)&#123; e.printStackTrace();&#125; 2. 线程的加入（join）不是静态方法，作用是当前线程等待这个调用 join() 方法对象的线程结束在继续执行 join() 下一句代码。 1234567public static void main(String[] args) throws InterruptedException&#123; System.out.println("main start"); Thread t1= new Thread(new Worker("thread-1")); t1.start(); t1.join(); System.out.println("main end");&#125; 如例子，main 线程要等到 t1 线程运行结束之后，才会输入“main end”。如果没有 join 那么变成并行，“main end”可能会被提前打印出来。 没有实现让其他线程并发执行，线程是顺序执行的。 1234567891011121314151617public static void main(String[] args) throws InterruptedException &#123; System.out.println("main start"); Thread t1 = new Thread(new Worker("thread-1")); Thread t2 = new Thread(new Worker("thread-2")); t1.start(); //等待t1结束，这时候t2线程并未启动 t1.join(); //t1结束后，启动t2线程 t2.start(); //等待t2结束 t2.join(); System.out.println("main end"); &#125; 让t1、t2线程并行 12345678910111213141516171819public class JoinTest&#123; public static void main(String[] args) throws InterruptedException &#123; System.out.println("main start"); Thread t1 = new Thread(new Worker("thread-1")); Thread t2 = new Thread(new Worker("thread-2")); t1.start(); t2.start(); t1.join(); t2.join(); System.out.println("main end"); &#125;&#125; 3. 线程的让步 yield()yield()方法它也可以让当前正在执行的线程暂停，让出cpu资源给其他的线程。但是和sleep()方法不同的是，它不会进入到阻塞状态，而是进入到就绪状态。yield()方法只是让当前线程暂停一下，重新进入就绪的线程池中，cpu 调度重新调度，可能出现这样的情况：当某个线程调用yield()方法之后，调度器又将其调度出来重新进入到运行状态执行。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[位运算]]></title>
    <url>%2F%E4%BD%8D%E8%BF%90%E7%AE%97.html</url>
    <content type="text"><![CDATA[取出两个数的补码进行运算，在对补码（解决符号问题）进行位运算，然后反推原码就是结果 为什么 因为负数在运算时，需要转换正数的反码，然后由于符号位的问题，我们知道类似于时钟，10点到八点可以（-2）或者（+10），它们总和为12，同余，每十二进一位，同理，对于负数反码的符号位问题，可以加1进位，解决符号问题（-2的理论对应的是14，就是1110，而1110去掉符号位就是-2的补码，所以要反码加1，用补码进行运算解决符号问题） 按位与 (&amp;)（有正为正，无正为负）参与运算的两个数，换算成二进制后，进行与运算。只有当相应位上的数都是1时，改位才是1，否则位0 按位或（|）(有负为负，无负为正)参加运算的两个数，换算为二进制(0、1)后，进行或运算。只要相应位上存在1，那么该位就取1，均不为1，即为0。 123456将10与-10进行按位或(|)运算：0000 0000 0000 10101111 1111 1111 0110-----------------------1111 1111 1111 1110所以：10 | -10 = 1111 1111 1111 1110 按位异或（^）(同号得正，异号得负)参加运算的两个数，换算为二进制(0、1)后，进行异或运算。只有当相应位上的数字不相同时，该为才取1，若相同，即为0。 123456将10与-10进行按位异或(^)运算：0000 0000 0000 10101111 1111 1111 0110-----------------------1111 1111 1111 1100所以：10 ^ -10 = 1111 1111 1111 1100 可以看出，任何数与0异或，结果都是其本身。利用异或还可以实现一个很好的交换算法，用于交换两个数，算法如下： 123a = a ^ b;b = b ^ a;a = a ^ b; 取反（~）参加运算的两个数，换算为二进制(0、1)后，进行取反运算。每个位上都取相反值，1变成0，0变成1。 12345对10进行取反(~)运算：0000 0000 0000 1010---------------------1111 1111 1111 0101所以：~10 = 1111 1111 1111 0101 左移（&lt;&lt;）参加运算的两个数，换算为二进制(0、1)后，进行左移运算，用来将一个数各二进制位全部向左移动若干位。 12345对10左移2位(就相当于在右边加2个0)：0000 0000 0000 1010--------------------0000 0000 0010 1000所以：10 &lt;&lt; 2 = 0000 0000 0010 1000 = 40 注意，观察可以发现，左移一位的结果就是原值乘2，左移两位的结果就是原值乘4。 右移（&gt;&gt;）参加运算的两个数，换算为二进制(0、1)后，进行右移运算，用来将一个数各二进制位全部向右移动若干位。（正数右移高位需补0，负数右移高位需补1） 123456789101112131415正数移位对10右移2位(就相当于在左边加2个0)：0000 0000 0000 1010--------------------0000 0000 0000 0010所以：10 &gt;&gt; 2 = 0000 0000 0000 0010 = 2负数移位原码 -21000 0010补码1111 1110右移动两位 -&gt; 退位-1 -&gt;原码 1111 1111 1111 1110 1000 0001 (-1) 注意，观察可以发现，右移一位的结果就是原值除2，左移两位的结果就是原值除4，注意哦，除了以后没有小数位的，都是取整。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[集合]]></title>
    <url>%2F%E9%9B%86%E5%90%88.html</url>
    <content type="text"><![CDATA[简介大致分为四种 Set : 代表无需，不可重复的集合。 List： 代表有序，重复的集合 Map： 代表具有映射关系的集合 Queue： 代表队列集合实现 和数组的区别 数组长度必须得初始化长度，长度是要提前知道。容易固定无法动态改变。但是集合可以保存数量不确定的数据。同时还能保存映射关系数据（键值对 key-value） 数组的元素可以对象或者基本类型，而集合只能是对象（保存对象的引用而非本身） 集合有着封装，继承，多态的特性，通过方法和属性实现复杂操作。 图例MAP 类图例Map由key和value两个值组成。里面的key是不可重复的，key用户标识集合里的每项数据。接口Collection 接口 集合框架的根接口（Collection 继承了Iterable）其中包含的增删改查等多个方法操作，其中还有 lterator 来遍历集合元素。 lterator 迭代器 主要用法是为了遍历集合，其中有两个主要方法 12boolean hasNext();//如果有元素可以迭代，则返回truenext();//返回迭代的下一个元素 以下例子怎么迭代 123456789101112131415161718public class Demo &#123; public static void main(String[] args)&#123; //创建集合，添加元素 Collection&lt;String&gt; temp = new ArrayList&lt;String&gt;(); for(int i =0;i&lt;10;i++)&#123; temp.add(String.valueof(i)); &#125; //获取days集合的迭代器 Iterator&lt;String&gt; iterator = temp.iterator(); while(iterator.hasNext())&#123;//判断是否有下一个元素 String next = iterator.next();//取出该元素 //逐个遍历，取得元素后进行后续操作 ..... &#125; &#125;&#125; 注意：修改迭代变量的值是不会修改集合本身的元素。因为 lterator 并不是把集合元素传给迭代变量，只是传来值，如同参数传递。 set集合Set 就是 Collection ,没有添加新的方法，只是 Set 不也许添加重复元素，不同的行为。 List 集合元素有序，可重复的集合。集合中每个元素都有其对应的顺序索引。List集合允许使用重复元素，可以通过索引来访问指定位置的集合元素 。List集合默认按元素的添加顺序设置元素的索引，例如第一个添加的元素索引为0，第二个添加的元素索引为1……List作为Collection接口的子接口，可以使用Collection接口里的全部方法。而且由于List是有序集合，因此List集合里增加了一些根据索引来操作集合元素的方法。 Map 集合Map用户保存具有映射关系的数据，因此Map集合里保存着两组数，一组值用户保存Map里的key,另一组值用户保存Map里的value，key和value都可以是任何引用类型的数据。Map的key不允许重复，value可以重复。 Queue 集合Queue用户模拟队列这种数据结构，队列通常是指“先进先出”(FIFO，first-in-first-out)的容器。队列的头部是在队列中存放时间最长的元素，队列的尾部是保存在队列中存放时间最短的元素。新元素插入（offer）到队列的尾部，访问元素（poll）操作会返回队列头部的元素。通常，队列不允许随机访问队列中的元素。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[类]]></title>
    <url>%2F%E7%B1%BB.html</url>
    <content type="text"><![CDATA[类的组成当类的成员没有初始化的时候，都会给默认变量定义类的例子 1234567//访问限定词 关键词 类名public class ClassName&#123; //属性（变量，字段） //方法 &#125; 一 变量格式：修饰符+变量名(定义并初始化值)，如果是final 关键字修饰，则该变量是一个常量，常量不可以重新赋值 二 方法格式：修饰符+返回值+方法名(参数){执行体|方法体} 三 修饰词 3.1 public简称公共的，被修饰的类，属性以及方法不仅可以被跨类访问，而且也许跨包访问 3.2 private简称私有的，被修饰的类，属性以及方法只能被该类的对象访问（同类不同对象可以访问其私有变量），其子类不能访问，更不能跨包访问。 3.3 protect介于 public 和 private 之间的一种访问修饰符，被其修饰的类，属性以及方法只能被本身的方法以及子类访问，即使子类在不同的包中也可以访问，并且本包下的其他类也可以访问 3.4 default只能在本包下被访问，无论是类，接口等。 构造函数格式：修饰符+类名（）{} 注意：没有返回值，也不能用static静态修饰。如果一个我们没有给他定义构造函数时系统会为其创建一个无参的构造函数。 作用：通过该构造函数来创建这个类的实例对象。初始化这个类的信息。也可以通过构造函数传参。 修饰词public代码块静态代码块12345public class test&#123; static&#123; System.out.println("静态代码块"); &#125;&#125; 执行时机静态代码块在类被加载的时候就运行了，而且只能被运行一次，并且优先于各种代码块以及构造函数，如果有多个静态代码块，会按照书写顺序依次执行。 作用一个项目启动需要加载的很多配置文件等资源，我们就可以都放入静态代码块中。 注意 静态代码不能存在任何方法体中 静态代码块不能访问普通变量构造代码块少了 static 关键字12345public class test&#123; &#123; System.out.println("构造代码块"); &#125;&#125; 执行时机构造代码块在创建对象时被调用，每次创建对象都会调用一次，但是优先于构造函数执行。需要注意的是，听名字我们就知道，构造代码块不是优先于构造函数执行，而是依托于构造函数，也就是说，如果你不实例化对象，构造代码块是不会执行的。怎么理解呢？我们看看下面这段代码： 12345678public class test&#123; &#123; System.out.println(&quot;构造代码块&quot;); &#125; public test()&#123; System.out.println(&quot;无参构造函数&quot;); &#125;&#125; 反编译生成的 class 文件 123456public class test&#123; public test()&#123; System.out.println("构造代码块"); System.out.println("无参构造函数"); &#125;&#125; 如果是多个构造代码块，则执行顺序按照书写顺序依次进行。 普通代码块普通代码块和构造代码块的区别是，构造代码块是在类中定义的，而普通代码块是在方法体中定义的。且普通代码块的执行顺序和书写顺序一致。 123public void sayHello()&#123; System.out.println("普通代码块");&#125; 执行顺序静态代码块&gt;构造代码块&gt;构造函数&gt;普通代码块类的生成对象内存分布图]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>名词</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编码规范]]></title>
    <url>%2F%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83.html</url>
    <content type="text"><![CDATA[类名首字母要大写，如果类名由几个单词构成，把么把它们拼接在一起（也就是说，不要用下划线来分隔名字），其中每个内部首字母都采用大写 方法，字段（成语变量）以及对象引用名称等，公认的风格与类的风格一样，只是标识符的第一个字母小写]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关键字 surper 和 final]]></title>
    <url>%2F%E5%85%B3%E9%94%AE%E5%AD%97%20surper%20%E5%92%8C%20final.html</url>
    <content type="text"><![CDATA[surper 指向当前对象的父（超）类对象的一个指针，这个超类指的是离自己最近的一个父类 用法引用成员变量当子类的成员变量与父类同名使用 super.xxx。 来引用父类的成员。 引用成员方法当子类的成员方法与父类同名，可以用 super 来区分。写法也是 super.xxx(参数)。 引用构造函数super(参数)，调用父类的某个构造函数，并且要成为使用这个关键字的构造方法（只能在构造方法中使用，并且不能与this 同时使用）的第一条语句。 this 和 super 接近，它是表示自身的一个对象，代表对象本身（调用者），可以理解为：指向对象本身的指针。 用法引用成员变量和 super 类似，当方法参数和类中的成员变量同名，可以使用 this 来区别变量，用法 this.xxx; 引用成员方法用法 this.xxx(参数) 引用构造函数用法 this(参数)，并且要放在首行; 注意 super()和this()均需放在构造方法内第一行。 尽管可以用this调用一个构造器，但却不能调用两个。 this和super不能同时出现在一个构造函数里面，因为this必然会调用其它的构造函数，其它的构造函数必然也会有super语句的存在，所以在同一个构造函数里面有相同的语句，编译器也不会通过. this()和super()都指的是对象，所以，均不可以在static环境中使用。包括：static变量,static方法，static语句块。 super()和this()类似,区别是，super()从子类中调用父类的构造方法，this()在同一类内调用其它方法。 super 正常会在子类中的构造函数 隐晦调用 从本质上讲，this是一个指向本对象的指针, 然而super是一个Java关键字。 super 指父类，this 指子类]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>关键字</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[synchronized关键字]]></title>
    <url>%2Fsynchronized.html</url>
    <content type="text"><![CDATA[一. 概念（synchronized） java 中的关键字，是利用锁的机制来实现同步的。 特性 互斥性：即在同一时间只也许一个线程持有某个对象锁，同一时间只有一个线程对需要同步的代码块进行访问。 必须确保在锁被释放之前，对共享变量所做的修改，对于随后获得该锁的另一个线程是可见的（即在获得锁时应获得最新共享变量的值），否则另一个线程可能是在本地缓存的某个副本上继续操作从而引起不一致。 二. 对象锁和类锁对象锁在 Java 中，每个对象都会有一个 monitor 对象，这个对象其实就是 java 对象的锁（内置锁/对象锁），每个对象都有独立的对象锁，互不干扰。类锁在 Java 中，针对每个类也有一个锁，称为“类锁”，每一个类只有一个 class 对象锁。三 synchronized 的用法根据修饰的对象分类synchronized 可以修饰方法和代码块 修饰代码块 synchronized(this.object){} synchronized(类.class) 修饰方法 修饰静态方法 修饰非静态方法根据获取的锁分类 获取对象锁 synchronized(this|object){} 修饰非静态方法 获取类锁 synchronized(类.class) 修饰非静态方法/静态方法 附1234//修饰非静态方法public synchronized void test1() &#123;&#125;//修饰静态方法public synchronized static void test() &#123;&#125; 四. synchronized 例子1. 对象锁12345678910111213141516171819public class SynchorizedThread extends Thread &#123; @Override public void run() &#123; syn5(); &#125; public void syn5() &#123; System.out.println(Thread.currentThread().getName() + "_Sync5: " + new SimpleDateFormat("HH:mm:ss").format(new Date())); synchronized (new SynchorizedThread()) &#123; try &#123; System.out.println(Thread.currentThread().getName() + "_Sync5_Start: " + new SimpleDateFormat("HH:mm:ss").format(new Date())); Thread.sleep(2000); System.out.println(Thread.currentThread().getName() + "_Sync5_End: " + new SimpleDateFormat("HH:mm:ss").format(new Date())); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 后面所有的例子都是采用这四个线程，只是对方法进行修改 1234567891011public static void main(String args[]) &#123; SynchorizedThread syncThread = new SynchorizedThread(); Thread F_thread1 = new Thread(new SynchorizedThread(), "F_thread1"); Thread F_thread2 = new Thread(new SynchorizedThread(), "F_thread2"); Thread F_thread3 = new Thread(syncThread, "F_thread3"); Thread F_thread4 = new Thread(syncThread, "F_thread4"); F_thread1.start(); F_thread2.start(); F_thread3.start(); F_thread4.start(); &#125; 运行结果如下： 123456789101112F_thread2_Sync5: 08:49:36F_thread1_Sync5: 08:49:36F_thread4_Sync5: 08:49:36F_thread2_Sync5_Start: 08:49:36F_thread3_Sync5: 08:49:36F_thread4_Sync5_Start: 08:49:36F_thread1_Sync5_Start: 08:49:36F_thread3_Sync5_Start: 08:49:36F_thread1_Sync5_End: 08:49:38F_thread3_Sync5_End: 08:49:38F_thread4_Sync5_End: 08:49:38F_thread2_Sync5_End: 08:49:38 四个线程同时开始，同时结束，因为作为锁的对象与线程是属于不同的实例 2. 采用类锁，无论哪个类都会被拦截12345678910111213141516171819public class SynchorizedThread extends Thread &#123; @Override public void run() &#123; syn5(); &#125; public void syn5() &#123; System.out.println(Thread.currentThread().getName() + "_Sync5: " + new SimpleDateFormat("HH:mm:ss").format(new Date())); synchronized (test.class) &#123; try &#123; System.out.println(Thread.currentThread().getName() + "_Sync5_Start: " + new SimpleDateFormat("HH:mm:ss").format(new Date())); Thread.sleep(2000); System.out.println(Thread.currentThread().getName() + "_Sync5_End: " + new SimpleDateFormat("HH:mm:ss").format(new Date())); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 运行结果如下： 123456789101112F_thread2_Sync5: 09:26:25F_thread3_Sync5: 09:26:25F_thread4_Sync5: 09:26:25F_thread1_Sync5: 09:26:25F_thread2_Sync5_Start: 09:26:25F_thread2_Sync5_End: 09:26:27F_thread3_Sync5_Start: 09:26:27F_thread3_Sync5_End: 09:26:29F_thread4_Sync5_Start: 09:26:29F_thread4_Sync5_End: 09:26:31F_thread1_Sync5_Start: 09:26:31F_thread1_Sync5_End: 09:26:33 可以发现，采用类锁一次只能通过一个，即使是不同的类，也只能通过一个。 3. 采用 this 对象锁12345678910111213141516171819public class SynchorizedThread extends Thread &#123; @Override public void run() &#123; syn5(); &#125; public void syn5() &#123; System.out.println(Thread.currentThread().getName() + "_Sync5: " + new SimpleDateFormat("HH:mm:ss").format(new Date())); synchronized (this) &#123; try &#123; System.out.println(Thread.currentThread().getName() + "_Sync5_Start: " + new SimpleDateFormat("HH:mm:ss").format(new Date())); Thread.sleep(2000); System.out.println(Thread.currentThread().getName() + "_Sync5_End: " + new SimpleDateFormat("HH:mm:ss").format(new Date())); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 结果如下： 123456789101112F_thread2_Sync5: 09:40:29F_thread1_Sync5: 09:40:29F_thread4_Sync5: 09:40:29F_thread1_Sync5_Start: 09:40:29F_thread3_Sync5: 09:40:29F_thread2_Sync5_Start: 09:40:29F_thread4_Sync5_Start: 09:40:29F_thread1_Sync5_End: 09:40:31F_thread2_Sync5_End: 09:40:31F_thread4_Sync5_End: 09:40:31F_thread3_Sync5_Start: 09:40:31F_thread3_Sync5_End: 09:40:33 可以发现1，2同时结束，3是等4结束后才开始，它们是同一对象 4. 修饰方法作用范围是整个方法 非静态方法1234567891011121314151617public class SynchorizedThread extends Thread &#123; @Override public void run() &#123; syn5(); &#125; public synchronized void syn5() &#123; System.out.println(Thread.currentThread().getName() + "_Sync5: " + new SimpleDateFormat("HH:mm:ss").format(new Date())); try &#123; System.out.println(Thread.currentThread().getName() + "_Sync5_Start: " + new SimpleDateFormat("HH:mm:ss").format(new Date())); Thread.sleep(2000); System.out.println(Thread.currentThread().getName() + "_Sync5_End: " + new SimpleDateFormat("HH:mm:ss").format(new Date())); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 结果为： 123456789101112F_thread2_Sync5: 09:44:45F_thread3_Sync5: 09:44:45F_thread1_Sync5: 09:44:45F_thread2_Sync5_Start: 09:44:45F_thread1_Sync5_Start: 09:44:45F_thread3_Sync5_Start: 09:44:45F_thread3_Sync5_End: 09:44:47F_thread1_Sync5_End: 09:44:47F_thread2_Sync5_End: 09:44:47F_thread4_Sync5: 09:44:47F_thread4_Sync5_Start: 09:44:47F_thread4_Sync5_End: 09:44:49 可以发现和this对象锁很像，同一个实例的线程访问会被拦截，非同一实例可以同时访问 修饰静态方法12345678910111213141516public class SynchorizedThread extends Thread &#123; @Override public void run() &#123; syn5(); &#125; public static synchronized void syn5() &#123; System.out.println(Thread.currentThread().getName() + "_Sync5: " + new SimpleDateFormat("HH:mm:ss").format(new Date())); try &#123; System.out.println(Thread.currentThread().getName() + "_Sync5_Start: " + new SimpleDateFormat("HH:mm:ss").format(new Date())); Thread.sleep(2000); System.out.println(Thread.currentThread().getName() + "_Sync5_End: " + new SimpleDateFormat("HH:mm:ss").format(new Date())); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 结果为： 123456789101112F_thread1_Sync5: 09:47:50F_thread1_Sync5_Start: 09:47:50F_thread1_Sync5_End: 09:47:52F_thread4_Sync5: 09:47:52F_thread4_Sync5_Start: 09:47:52F_thread4_Sync5_End: 09:47:54F_thread3_Sync5: 09:47:54F_thread3_Sync5_Start: 09:47:54F_thread3_Sync5_End: 09:47:56F_thread2_Sync5: 09:47:56F_thread2_Sync5_Start: 09:47:56F_thread2_Sync5_End: 09:47:58 可以发现是和类锁一样 总结 对于静态方法，由于此时对象还未生成，采用类锁。 只要是类锁，就会拦截所有的线程，只能让一个线程访问。 对于对象锁（this/Object）,如果是同一个实例，就会按照顺序进行访问，但是如果是不同的实例，就能同时访问 如果对象锁跟访问的对象没有关系，那么就都会同时访问。 synchronized 关键字不能被继承。对于父类中的 synchronized 修饰的方法，子类覆盖的时候，默认情况是不同步的，必须使用 synchronized 关键字修饰才行。 定义接口时候不能使用 synchronized 关键字 构造方法不能使用 synchronized 关键字，但可以使用 synchronized 代码块同步。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>关键字</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[String字符串]]></title>
    <url>%2FString%E5%AD%97%E7%AC%A6%E4%B8%B2.html</url>
    <content type="text"><![CDATA[一. String 简介 不可变 StringString 对象是不可改变的，String类中每一个==看起来会修改String对象值得方法，实际上都是创建了一个全新得String对象==，包含了修改后得字符串内容，最初得原始对象没有改变过 String 源码1. String 属性值1234567891011121314151617181920212223242526272829public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123; /** The value is used for character storage. */ private final char value[]; /** Cache the hash code for the string */ private int hash; // Default to 0 /** use serialVersionUID from JDK 1.0.2 for interoperability */ private static final long serialVersionUID = -6849794470754667710L; /** * Class String is special cased within the Serialization Stream Protocol. * * A String instance is written into an ObjectOutputStream according to * &lt;a href="&#123;@docRoot&#125;/../platform/serialization/spec/output.html"&gt; * Object Serialization Specification, Section 6.2, "Stream Elements"&lt;/a&gt; */ private static final ObjectStreamField[] serialPersistentFields = new ObjectStreamField[0]; /** * Initializes a newly created &#123;@code String&#125; object so that it represents * an empty character sequence. Note that use of this constructor is * unnecessary since Strings are immutable. */ ...... &#125; 2. String 构造函数1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980/** * Initializes a newly created &#123;@code String&#125; object so that it represents * an empty character sequence. Note that use of this constructor is * unnecessary since Strings are immutable. */ public String() &#123; this.value = "".value; &#125; /** * Initializes a newly created &#123;@code String&#125; object so that it represents * the same sequence of characters as the argument; in other words, the * newly created string is a copy of the argument string. Unless an * explicit copy of &#123;@code original&#125; is needed, use of this constructor is * unnecessary since Strings are immutable. * * @param original * A &#123;@code String&#125; */ public String(String original) &#123; this.value = original.value; this.hash = original.hash; &#125; /** * Allocates a new &#123;@code String&#125; so that it represents the sequence of * characters currently contained in the character array argument. The * contents of the character array are copied; subsequent modification of * the character array does not affect the newly created string. * * @param value * The initial value of the string */ public String(char value[]) &#123; this.value = Arrays.copyOf(value, value.length); &#125; /** * Allocates a new &#123;@code String&#125; that contains characters from a subarray * of the character array argument. The &#123;@code offset&#125; argument is the * index of the first character of the subarray and the &#123;@code count&#125; * argument specifies the length of the subarray. The contents of the * subarray are copied; subsequent modification of the character array does * not affect the newly created string. * * @param value * Array that is the source of characters * * @param offset * The initial offset * * @param count * The length * * @throws IndexOutOfBoundsException * If the &#123;@code offset&#125; and &#123;@code count&#125; arguments index * characters outside the bounds of the &#123;@code value&#125; array */ public String(char value[], int offset, int count) &#123; if (offset &lt; 0) &#123; throw new StringIndexOutOfBoundsException(offset); &#125; if (count &lt;= 0) &#123; if (count &lt; 0) &#123; throw new StringIndexOutOfBoundsException(count); &#125; if (offset &lt;= value.length) &#123; this.value = "".value; return; &#125; &#125; // Note: offset or count might be near -1&gt;&gt;&gt;1. if (offset &gt; value.length - count) &#123; throw new StringIndexOutOfBoundsException(offset + count); &#125; this.value = Arrays.copyOfRange(value, offset, offset+count); &#125; ...... ...... ..... 从上面得源码可以知道，==String得value属性值是一个字符数组，字符串实际由字符串数组组成，并且被final修饰，所以不能被修改==。 二 创建字符串的两种方式2.1 通过构造方法创建字符串对象通过构造函数创建的字符串是==在堆内存== 1String str=new String("hello"); ++这里创建了多少对象++？2个。原因： jvm 会在 String pool 中寻找是否存在 “hello” ,如果没有则创建，有则什么都不做 之后遇到了 new ，又在 Java head 中创建了一个对象用了存储 “hello” 所以一共创建了两个 2.2 通过直接赋值创建字符串1String str="hello"; 通过直接赋值创建的对象是在==方法区的常量池== 2.3 两种实例化方法的比较代码上的比较 12345678910111213141516171819public class TestString &#123; public static void main(String[] args) &#123; String str1 = "Lance"; String str2 = new String("Lance"); String str3 = str2; //引用传递，str3直接指向st2的堆内存地址 String str4 = "Lance"; /** * ==: * 基本数据类型：比较的是基本数据类型的值是否相同 * 引用数据类型：比较的是引用数据类型的地址值是否相同 * 所以在这里的话：String类对象==比较，比较的是地址，而不是内容 */ System.out.println(str1==str2);//false System.out.println(str1==str3);//false System.out.println(str3==str2);//true System.out.println(str1==str4);//true &#125;&#125; 内存图比较如图 2.4 字符串常量池在字符串中，如==果采用直接赋值的方法进行对象的实例化，则会将匿名对象放入字符串常量池==，每当下一次==对不同的对象进行直接赋值时，会直接利用池中的原有的匿名对象==。 2.5 总结 直接赋值：开辟一块堆内存空间，并且自动入池，==不会产生垃圾== 构造函数：==会开辟两块内存堆空间，其中一块堆内存会变成垃圾被系统回收掉==，而且不能够自动入池，要手动入池，==另一块堆空间存储值。== 在开发过程中尽量不用采用构成函数来进行字符串实例化 三 String不可变性质意思是：String是个常量，从一出生就注定不可变从第一点就看到，String 是被 final 所修饰的，不可变，以下是经典例子 1234567891011public class Apple &#123; public static void main(String[] args) &#123; String a = "abc"; String b = "abc"; String c = new String("abc"); System.out.println(a==b); //true System.out.println(a.equals(b)); //true System.out.println(a==c); //false System.out.println(a.equals(c)); //true &#125;&#125; 3.1 原因因为有着字符串常量池的的缘故，每次当直接赋值时，jvm 都会在池寻找是否已经存在该字符串，如果有，则使用同一个字符串,没有，则生成一个,所以，这也就是为什么上面的例子 a==b 为 true , a==c 为 false ,因为变量只是保存地址值，==比较的是地址，而，equals() 比较的字符串的内容。以上的这种模式，叫做享元模式 3.2 String 不变的好处可以实现多个变量引用堆内存中的同一个字符串实例，避免创建的开销。 我们的程序中大量使用了String字符串，有可能是出于安全性考虑。 大家都知道HashMap中key为String类型，如果可变将变的多么可怕。 当我们在传参的时候，使用不可变类不需要去考虑谁可能会修改其内部的值，如果使用可变类的话，可能需要每次记得重新拷贝出里面的值，性能会有一定的损失。 3.3 重载”+”与StringBuilder 构建字符串1234567public class test&#123; public static void main(String[] agrs)&#123; String mango="hello"; String s="abc"+mango+"def"+47; System.out.println(s); &#125;&#125; 上面的这段代码，我们会这样想，String可能有个 append() 方法，他会生成一个新的String对象，这个新生成的对象包好了“abc” 与 mango 连接后的字符串，以此类推。 但是这种工作方式，我们知道，他最终生成的String对象中途会产生一堆垃圾回收的中间对象。这样会发现性能相当糟糕 通过反编译字节码我们看到编译器自动使用了 StringBuilder 类来构造最终 String 对象，并且调用StringBuilder 的 append() 方法，总计四次，然后调用toString() 生成结果。 现在可能认为编译器会自动优化，这里在使用两种不同的方式来生成 String 比较，一种使用多个 String 对象，一种使用 StringBuilder 反编译之后，首先是 implicit() 方法 可以看出，从第8行开始到第35行都在重复的生成 StringBuilder 对象 explicit() 方法 我们可以看的，代码量进行了缩短，并且只生成了一个 StringBuilder 对象。 所以==如果是简单字符串，可以交给编译器来合理构造，不然使用 StringBuilder 对象的 append() 方法一个个拼接起来== 附加（字符串常量+字符串常量=字符串常量？）对于以下代码 123456789String test1="helloworld";String test2="hello"+"world";String test3="hello";String test4=test3+"world";String test5=new String("helloworld");System.out.println(test1==test2);//trueSystem.out.println(test1==test4);//falseSystem.out.println(test1==test5);false 从上面代码例子中看出，为什么 test1==test2 会 true ，而test1==test4 会 false。（1） 对于test1 为什么会等于 test2 ,因为两个都是字面字符串常量，Java 在编译期间，就会将两边拼接起来，因为编译器认为这个时候的值是不会发生改变，这个运算即使放在运行时不会变化，所以编译期就放到同一个常量池中了。（2） 在 test4 中有一变量（严格意义上的变量，可以被改变的数据，可大可小可长可短能伸能缩，所有需要一次以上处理才能成为直接字面字符的 值存在时 java都一律将其视为变量），无论这里几个变量，因为 Java 并不知道这里 test3 到底是什么，只知道他是一个 String 变量（在编译期），具体值是在运行时而去处理，和多态很像。从前面的知识点得知，Java 在处理字符串变量 + 时会生成一个 StringBuilder 的 append（） 方法，最后 toString() 方法来获得字符串，这是就 new 出来了一个新的堆空间，就不一样了。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[异常]]></title>
    <url>%2F%E5%BC%82%E5%B8%B8.html</url>
    <content type="text"><![CDATA[异常指的程序或者电脑发生不正常的现象所引发程序无法执行和崩溃，例如：文件找不到，网络连接失败等待。 在 java 中，异常都是对象，是 Throwable 的子类，Throwable 的子类都描述着不同的异常和错误。如下图，Java 异常类层次结构图 一 异常的架构体系1.1Throwable（超类）所有异常的祖先，用两个重要的子类：Exception（异常），Error（错误），两者各自也包含了大量的子类。 1.1.1 Error（错误）是程序无法处理的错误，意思是运行程序中较为严重的问题，表示 jvm 出现了问题,大多数与代码编写者的操作无关，例如 virtual machineError ，当 JVM 不再有继续执行操作所需的内存资源时，将出现 OutOfMemoryError。这些异常发生时，Java虚拟机（JVM）一般会选择线程终止 1.1.2 Exception（异常）是程序本身可以处理的异常。Exception 有一重要的子类， RuntimeException。RuntimeException 类及其子类表示“JVM 常用操作”引发的错误。例如，若试图使用空值对象引用、除数为零或数组越界，则分别引发运行时异常。 1.1.3 可查异常 （checked exceptions） 编译器要求必须处置的异常 非运行时异常又叫做编译异常，除了 RuntimeException 及它的子类以外的 Excetion 的子类（都是可查异常），如果不处理是不会编译通过 1.1.4 不可查异常（unchecked exceptions ） 编译器不要求强制处理的异常，包括运行时异常（RuntimeException 以及它的子类 还有错误） 其中运行时异常），程序可以选择捕获处理也可以不处理。因为编译器是不会检查它，没有两种异常处理方式也能通过编译。 二 处理异常机制 一共有两种处理异常机制，分别是抛出异常，捕捉异常 2.1 捕捉异常 关键字 try catch finally 1. try-catch形式 12345678try&#123; //可能会发生的异常代码 //监控区域&#125;catch(Kind1 e)&#123; //捕获并处置try抛出的异常类型kind1&#125;catch(Kind2 e)&#123; //捕获并处置try抛出的异常类型kind2&#125; 当try中（监控区域出现异常）则抛出监控区域之外，Java 会试图寻找匹配的 catch 字句，以捕获异常，若有匹配则执行 catch 中的语句，try-catch 语句结束注意：catch 语句中的异常不一定匹配对应所抛出的异常，可以是对应的异常类，也可以对应的异常类的子类 一旦某个 catch 捕获到匹配的异常类型，就进入异常处理，并且其他的 catch 语句将不会被匹配和捕获异常的机会 对于多个异常，应尽量及将低层的类（子类）捕获的异常类的 catch 语句防止前面，相对高层的异常类放在后面，不然高层的父类放前面可能会屏蔽子类的。 2. finally语句 123456789try&#123; &#125;catch(Kind kind1)&#123; &#125;catch(Kind kind2)&#123; &#125;finally&#123; //无论发生什么异常，都将执行该语句块&#125; 注意：在 finally 语句中使用 return 语句以及抛出新的异常，会导致原有抛出的异常丢失。当 try 块或者 catch 语句块遇到 return 语句时，finally 语句块将在方法返回之前执行，如果 finally 同时也有 return 语句，try 和 catch 语句的 return 将被覆盖。 3. 执行顺序 try 没有捕获异常时： try 语句被逐一执行并且在执行完 try 之后的 catch 忽略， finally 和之后语句继续执行 当try捕获到异常，catch语句块里没有处理此异常的情况： 当try语句块里的某条语句出现异常时，而没有处理此异常的catch语句块时，此异常将会抛给JVM处理，finally语句块里的语句还是会被执行，但finally语句块后的语句不会被执行。 当try捕获到异常，catch语句块里有处理此异常的情况： 当执行某一条语句出现异常时，程序将逐一匹配 catch ，找到与之对应的处理程序，其他的catch语句块将不会被执行，而try语句块中，出现异常之后的语句也不会被执行，catch语句块执行完后，执行finally语句块里的语句，最后执行finally语句块后的语句； 2.2 抛出异常 throws 抛出异常 123public(...) void methodname throws Exception1,Exception2,,,&#123; //.......&#125; 如果一个方法可能会出现异常，但没有能力处理这种异常，可以在方法声明出用 throws 语句来声明抛出的异常。并且也可以在方法体内写 throw 语句 throws 语句用在方法定义时要抛出的类型。Exception 则是所有异常。多个类型用逗号分隔。此时抛出的异常，将交给调用该方法的方法处理。 注意： 如果时不可查异常，即Error，RuntimeException以及子类，那么可以不用 throws 声明要抛出的异常，由系统自动抛出。 如果时可查异常。即比如IOException ,就要么使用 try catch 来捕获，要么使用 throws 字句声明将他抛出。 仅仅抛出的异常，该方法的调用者必须处理或者重新抛出 覆盖一个方法，不能声明与覆盖方法不同的异常，必须是覆盖方法声明的异常同类或子类。 使用 throw 抛出异常 throw 是在方法体当中，抛出 Throwable 类型异常，程序会在 throw 语句之后立即结束程序 1throw new Exception(); 注意： 抛出的异常只能是 Throwable 类或者子类 如果抛出了检查异常，则还要在方法头部声明方法可能抛出的异常类型。该方法调用者也必须检查处理抛出的异常。 三 Throwable 常用的方法catch关键字后面括号中的Exception类型的参数e。Exception就是try代码块传递给catch代码块的变量类型，e就是变量名。catch代码块中语句”e.getMessage();”用于输出错误性质。通常异常处理常用3个函数来获取异常的有关信息: getCause()： 返回抛出异常的原因。如果 cause 不存在或未知，则返回 null。 getMeage()： 返回异常的消息信息。 printStackTrace()： 对象的堆栈跟踪输出至错误输出流，作为字段 System.err 的值。自定义异常只需要基础 Exception 类即可步骤 创建自定义异常类 在方法中通过 throw 关键字抛出异常对象 如果在当前抛出异常的方法中处理异常，可以使用try-catch语句捕获并处理；否则在方法的声明处通过throws关键字指明要抛出给方法调用者的异常，继续进行下一步操作。 在出现异常方法的调用者中捕获并处理异常。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>Exception</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F%E7%BB%A7%E6%89%BF.html</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Map集合]]></title>
    <url>%2FMap%E9%9B%86%E5%90%88.html</url>
    <content type="text"><![CDATA[概述 对比 Collection 中的集合，Map 集合中的元素是成对存在，每个元素由键与值两部分组成，通过键找到所对应的值。 注意的是：Map 集合中不能包含重复的键，值可以重复；每个键对应一个值。 常用集合 Map 中常用的集合为 HashMap 集合，LinkedHashMap 集合。 HashMap&lt;K,V&gt; 存储数据采用的哈希表结构，所以是无序的，并且为了键的唯一性，不重复，需要重写键的 hashCode() 方法，equals() 方法 概述 他是一个散列表，对比Collection 的单列集合，它是一个双列集合。存储内容是键值对（key-value）一对一的关系映射。 并且线程是不同步的，可以存入 null 键，null 值。 HashMap 与 Hashtable 的区别 Hashtable 是一个线程安全的 Map 实现， 但是 HashMap 是线程不安全的实现（底层都是哈希表数据结构），所以 HashMap 比 Hashtable 的性能好一些，但是多个线程访问同一个 Map 对象时，使用 Hashtable 会好一些 Hashtable 不也许使用 null 键作为 key 和 value ,如果把 null 值放入 Hashtabke 中，将会引发 NullPoiniterException 异常，但是 HashMap 可以使用 null 作为 key 或 value。为什么 Key 值需要重写 hashCode() 和 equals()在添加元素，HashMap 的判断步骤 首先会使用当前集合中的每个元素和新添加的元素进行 hash 值比较 如果 hash 值不一样，则添加新的元素 如果 hash 值一样，比较地址值或者使用 equals() 方法进行比较 比较结果一样，则认为重复不添加 所有的比较结果都不一样则添加12345678 Student stu1= new Student("张三", "10000", 18, "男", "软件工程", 1000.00);Student stu2= new Student("张三", "10000", 18, "男", "软件工程", 1000.00);HashMap&lt;Student, String&gt; map= new HashMap&lt;&gt;();map.put(stu1, "我是第一个");map.put(stu2, "我是第二个");System.out.println(map.get(stu1));System.out.println(map.get(stu2)); 以上代码结果为 12我是第一个我是第二个 明明是同样的数据，可是为什么添加进去了呢，因为，Object 的 hashcode() 方法是通过对象的地址计算出哈希值，所以不同的对象，地址不同也就添加进去了（equals()也是一样），为了区分不同所以得重写 hashCode() 和 equals() ,因为 equals() 在 hashCode() 相同的情况下（毕竟 hash 值也是会发生冲突的）通过 equals() 判断 key 特有的 ID 值来区别不同。建议： 尝试让 hashCode 方法的返回值和对象的成员变量有关 可以让 hashCode 方法返回所有成员变量之和。 让基本数据类型直接相加，然后引用数据类型获取 hashCode 方法返回值后再相加（boolean 不可参与运算） 遍历方式 遍历 HashMap 的键值对 根据entrySet()获取 HashMap 的“键值对”的 Set 的集合 通过 Iterator 迭代器遍历第一步得到的集合 1234567891011//Entry 相当于就是 Map 中的每个 key-value 只保存下来的单个记录点//每个 Entry 就保存一个 key 以及它所对应的 value 。Set是集合Set&lt;Entry&lt;String, Student&gt;&gt; keys = map.entrySet();Iterator&lt;Entry&lt;String, Student&gt;&gt; iterator= keys.iterator();//当下一个有值时while(iterator.hasNext()) &#123; //读取单个的 Entry 对象 Entry&lt;String, Student&gt; key=iterator.next(); System.out.println(key.getKey()); System.out.println(key.getValue().toString());&#125; 遍历 HashMap 的键 根据keySet()获取HashMap的“键”的Set集合。 通过 Iterator 迭代器遍历第一步得到的集合12345678 Set&lt;String&gt; keys=map.keySet();Iterator&lt;String&gt; iterator= keys.iterator();//当下一个有值时while(iterator.hasNext()) &#123; String key=iterator.next(); Student value=map.get(key); System.out.println(value);&#125; 遍历 HashMap 的值 根据value()获取HashMap的“值”的集合。 通过 Iterator 迭代器遍历第一步得到的集合12345678 //只能获取值，不能获取键 Collection&lt;Student&gt; values = map.values(); Iterator&lt;Student&gt; iterator = values.iterator();//当下一个有值时 while(iterator.hasNext()) &#123; Student value = iterator.next(); System.out.println(value.toString());&#125; 内部结构HashMap 构造函数1234567891011// 默认构造函数。HashMap()// 指定“容量大小”的构造函数HashMap(int capacity)// 指定“容量大小”和“加载因子”的构造函数HashMap(int capacity, float loadFactor)// 包含“子Map”的构造函数HashMap(Map&lt;? extends K, ? extends V&gt; map) 概括 HashMap 是通过“拉链法”实现的哈希表。它包括 table,size,threshold,loadFactor table 是一个 Node[] 数组类型，而 Node 实际就是一个单项链表。数组用来存放 一个Node的头节点（理解为key 的 hashCode() ）的值，以便插入先利用 hashCode 寻址。 size HashMap的大小，它是HashMap保存的键值对的数量。 threshold threshold是HashMap的阈值，用于判断是否需要调整HashMap的容量。threshold的值=”容量*加载因子”，当HashMap中存储数据的数量达到threshold时，就需要将HashMap的容量加倍。 loadFactor 加载因子 Node 节点源代码 12345678910111213141516171819202122232425262728293031323334353637383940414243static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final int hash; final K key; V value; // 指向下一个节点 Node&lt;K,V&gt; next; //构造函数。 // 输入参数包括"哈希值(hash)", "键(key)", "值(value)", "下一节点(next)" Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; this.hash = hash; this.key = key; this.value = value; this.next = next; &#125; public final K getKey() &#123; return key; &#125; public final V getValue() &#123; return value; &#125; public final String toString() &#123; return key + "=" + value; &#125; public final int hashCode() &#123; return Objects.hashCode(key) ^ Objects.hashCode(value); &#125; public final V setValue(V newValue) &#123; V oldValue = value; value = newValue; return oldValue; &#125; // 判断两个Node是否相等 // 若两个Node的“key”和“value”都相等，则返回true。 // 否则，返回false public final boolean equals(Object o) &#123; if (o == this) return true; if (o instanceof Map.Entry) &#123; Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o; if (Objects.equals(key, e.getKey()) &amp;&amp; Objects.equals(value, e.getValue())) return true; &#125; return false; &#125; &#125; HashMap 的哈希表，就是存储这数组和链表两种结构。数组的特点就是连续空间，寻址速度，但是删除或增加困难，链表则是正好相反，由于空间的不连续，查找速度慢，但增加删除只需要改指针，速度块。这种叫做“拉链法”。图中，我们可以发现哈希表是由数组+链表組成的，一个长度为16的数组中，每個元素存储的是一个链表的头结点。一般情況是通过hash(key)获得，也就是元素的key的哈希值。如果hash(key)值相等，则都存入该hash值所对应的链表中。它的內部其实是用一個Node数组來实现。 LinkedHashMap LinkedHashMap使用双向链表来维护key-value对的次序。LinkedHashMap 的性能略低于HashMap的性能，因为要拍顺序；但由于它以链表，所以在迭代访问Map里的全部元素时有较好速度。迭代输出LinkedHashMap的元素时，将会按照添加key-value对的顺序输出。 本质上来讲，LinkedHashMap=散列表+循环双向链表 TreeMap TreeMap是SortedMap接口的实现类。TreeMap 是一个有序的key-value集合，它是通过红黑树实现的，每个key-value对即作为红黑树的一个节点。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>Map</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[List集合]]></title>
    <url>%2FList%E9%9B%86%E5%90%88.html</url>
    <content type="text"><![CDATA[有序集合，可以存放重复的元素； 实现类ArrayList 数组实现，查询块，增删慢，轻量级。（线程不安全） 底层是 Object 数组，动态的，通过判断大小是否超过来 copy 数组，并且重新赋予新的空间。能够拥有数组的查找速度快的特点，但是，也造成了增删慢的缺点。 遍历方式（01）第一种，迭代器 12345Integer value = null;Iterator iter = list.iterator();while (iter.hasNext()) &#123; value = (Integer)iter.next();&#125; （02）第二种，索引值访问 12345Integer value = null;int size = list.size();for (int i=0; i&lt;size; i++) &#123; value = (Integer)list.get(i); &#125; （03）增强 for 遍历 1234Integer value = null;for (Integer integ:list) &#123; value = integ;&#125; 注意：使用索引值访问效率最高，而迭代器最低 LinkedList 双向链表实现，增删块，查询慢（线程不安全）底层是一个双向循环链表，所以在插入和删除上会更好，但是对比 ArrayList ,随机访问也就是查询性能差。 遍历方式 通过迭代器 随机访问 增强 for 循环 通过 pollFirst() 通过 pollLast() 通过 removeFirst() 通过 removeLast() 注意：逐个遍历，效率最高，随机访问效率最低。LinkedList() 可以用来实现栈（stack），队列（queue），双向队列，因为它具有 addFirst(), getFirst(),getLast(),removeFirst(),removeLast()等。 Vector 数组实现，重量级（线程安全，使用少） 和 ArrayList 相似在考虑的清空下使用 Vector ( 保证线程安全 ) 总结对于“单线程环境”或者“多线程环境，但 List 仅仅只会被单个线程操作“，此时应该使用非同步类（如 ArrayList ）,对于多线程环境，且 list 可能同时被多个线程操作，此时应该使用同步的类（如 Vector ）]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java中的引用]]></title>
    <url>%2Fjava%E4%B8%AD%E7%9A%84%E5%BC%95%E7%94%A8.html</url>
    <content type="text"><![CDATA[参考来源 点击这里 值类型与引用类型12int num=10;String str="hello"; 从上图中可以看出基本数据类型保存的是值，而引用数据类型保存的是指向对象的地址信息，不是值 变量赋值12num=20;str="java"; 对于基本数据类型，如果赋值会覆盖掉原来的数，而对于引用数据类型，重新赋值的话，会覆盖原本保存的地址信息，而去指向新的对象，原来对象没有改变过，此时原来的对象则会因没有引用来关联找不到它，就会被垃圾回收器回收。 函数传参1234567891011121314151617StringBuilder sb1 = new StringBuilder("test");StringBuilder sb2 = new StringBuilder("test");// 对于提供修改自身的成员方法引用类型，原始的sBuilder会被更改public void func(StringBuilder sBuilder) &#123; sBuilder.append("aa");&#125;// 原始的sBuilder不会被更改public void test(StringBuilder sBuilder) &#123; sBuilder = new StringBuilder("111");&#125;public static void main(String s)&#123; func(sb1); test(sb2);&#125; 在执行 main 里面的 &ensp;func(sb1)&ensp;之后执行 main 里面的 test(sb2) 后]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>引用</tag>
        <tag>基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java8新特性和default]]></title>
    <url>%2Fjava8%E6%96%B0%E7%89%B9%E6%80%A7%E5%92%8Cdefault.html</url>
    <content type="text"><![CDATA[新特性 JDK1.8 为了加强接口的实用能力，使得接口可以存在具体的方法，前提是方法需要被 default 和 static 修饰 12345678public interface D &#123; default void method1() &#123; System.out.println("我是接口的默认方法"); &#125; static void method2() &#123; System.out.println("我是接口的静态方法"); &#125;&#125; 注意： 用 default 修饰的方法必须是用方法体，不能方法体为空，不能用以下形式声明在接口 1default void method1(); 如果一个 A 类继承 B,C 两个接口，此时接口中用同名的 default 修饰的方法，那么此时编译器会报错，编译器不知道调用哪一个。 default 方法不能通过类名调用（对象级），static 方法可以通过类名调用（类级）。 一个接口可以有多个default方法, 也可以有多个static方法 defautl另一种使用方法 以上是 default 的一种使用方法，另外一种则是在 switch 语句中，在 switch 中如果没有与 case 匹配的就与 default 匹配，这里就不多介绍了。 总结 default 可以使得接口有具体的默认方法 default 修饰的方法，被继承的子类也同时具有该默认方法，并且可以被重写 主要是解决继承该接口的类有些具有同样的方法功能，每个类都要写这段重复的代码，显然费时，这也是新特性的意义。 附注意这里的 default 与类中的 default 的修饰词是不一样的，两者意义不同，而且类中 default 是不能显示写出来，而是默认如果你没有写修饰符，默认就是 default ，所以不能写出来。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IO流]]></title>
    <url>%2FIO%E6%B5%81.html</url>
    <content type="text"><![CDATA[我们对文件的操作，大多都是通过 IO 流来操作的，那什么是流呢？ 一 流和水流类似，它只是变成了一组有顺序，连续字节的数据流，并且有开始和结束的位置，并且它的方向很重要。透明通常利用方向来区别它们的作用。 分类 根据流向分为：输入流和输出流 输入流：数据源（磁盘）—&gt; 内存 输出流：内存—&gt; 媒介 （磁盘等） 根据类型分为：字符流和字节流 字节流：以字节为单位的进行读写，一次是8为二进制。 字符流：以字符为单位进行读写。一次是16为二进制。使用环境 字节流输入字节流 InputStream InputStream 是所有输入字节流的父类，他是一个抽象类 ByteArrayInputStream、StringBufferInputStream、FileInputStream 是三种基本的介质流，它们分别从Byte 数组、StringBuffer、和本地文件中读取数据。 FileInputStream概念FileInputStream流被称为文件字节输入流，意思指对文件数据以字节的形式进行读取操作如读取图片视频等 构造方法第一种：通过打开与File类对象代表的实际文件的链接来创建FileInputStream流对象 1public FileInputStream(File file) throws FileNotFoundException&#123;&#125; 注意：若File类对象的所代表的文件不存在;不是文件是目录;或者其他原因不能打开的话，则会抛出FileNotFoundException第二种：通过指定的字符串参数来创建File类对象，而后再与File对象所代表的实际路径建立链接创建FileInputStream流对象,发现该构造方法等于是在第一个构造方法的基础上进行延伸的，因此规则也和第一个构造方法一致 1public FileInputStream(String name) throws FileNotFoundException 常用方法read() 数据的下一个字节（或者指定的长度），如果达到文件的末尾， -1 123456789 FileInputStream fin= new FileInputStream(file);//建立一个字节数组来保存读取的内容byte[] by=new byte[1024];//保存当前读取的长度int size= 0;while((size=fin.read(by))!=-1) &#123; System.out.println(new String(by,0,size));&#125;fin.close(); 输出字节流 OutputStream OutputStream 是所有的输出字节流的父类，它是一个抽象类。 ByteArrayOutputStream、FileOutputStream 是两种基本的介质流，它们分别从Byte 数组、和本地文件中读取数据。FileOutputStreamFileOutputStream流是指文件字节输出流，专用于输出原始字节流如图像数据等，其继承OutputStream类，拥有输出流的基本特性1public class FileOutputStream extends OutputStream&#123;&#125; 构造函数第一种：创建FileOutputStream流以写入数据到File对象所代表的文件，同时创建一个新的FileDescriptor对象来表示与该文件的关联(源码中会new一个该对象) 1public FileOutputStream(File file) throws FileNotFoundException&#123;&#125; 第二种：创建FileOutputStream流以写入数据到File对象表示的文件。 如果第二个参数为true，则字节将写入文件的末尾而不是开头。 创建一个新的FileDescriptor对象来表示此文件连接。其抛异常的规则与第一个构造函数一致 1public FileOutputStream(File file,boolean append) throws FileNotFoundException&#123;&#125; 若第二个参数为真，则意味着会写入字节到文件的末尾，意味着追加内容，若为假，则是写入字节到文件的开头，意味着是覆盖。（默认是覆盖）第三种：创建FileOutputStream流以写入数据到指定路径所代表的文件，同时创建一个新的FileDescriptor对象来表示与该文件的关联(源码中会new一个该对象) 1public FileOutputStream(String name) throws FileNotFoundException&#123;&#125; 第四种：创建FileOutputStream流以写入数据到指定路径所代表的文件，同时创建一个新的FileDescriptor对象来表示与该文件的关联(源码中会new一个该对象)， 如果第二个参数为true，则字节将写入文件的末尾而不是开头 1public FileOutputStream(String name,boolean append) throws FileNotFoundException 注意： 若文件存在，但是是目录而不是文件，则会抛出FileNotFoundException异常 若文件不存在则创建 若不存在且无法创建，则会抛出FileNotFoundException异常常用方法write()123456789101112 FileInputStream fin= new FileInputStream(file);FileOutputStream fout=new FileOutputStream("picture2.png");//建立一个字节数组来保存读取的内容byte[] by=new byte[1024];//保存当前读取的长度int size= 0;while((size=fin.read(by))!=-1) &#123; fout.write(by, 0, size); fout.flush();//刷流&#125;fout.close();fin.close(); 字符流输入字符流 Reader Reader 是所有输入字符流的父类，他是一个抽象类BufferedReaderBufferedReader类从字符输入流中读取文本并缓冲字符，以便有效地读取字符，数组和行可以通过构造函数指定缓冲区大小也可以使用默认大小。对于大多数用途，默认值足够大构造函数1BufferedReader(Reader in) 和上面的输入流类似，new出新对象的时候需要传入Reader的子类流，如下 1bufferRead = new BufferedReader(new InputStreamReader(new FileInputStream(path))); 常用的方法readLine()123456 bufferRead = new BufferedReader(new InputStreamReader(new FileInputStream(path))); String result;while ((result = bufferRead.readLine()) != null) &#123; System.out.println(result); &#125;&#125; 输出字符流 Writer Writer 是所有输出字符流的父类，他是一个抽象类BufferedWriter字符缓冲输出流构造函数1BufferedWriter(Wtiert in) ; 和上面的输入流类似，new出新对象的时候需要传入Writer的子类流，如下 1bufferWriter = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(path, true))); 常用方法writer()1234 bufferWriter = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(path, true))); String result="hello world"; bufferWriter.write(result);&#125; nextLine() public void newLine() throws IOException写入一个行分隔符。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>IO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ASCII码表]]></title>
    <url>%2FASCII%E7%A0%81%E8%A1%A8.html</url>
    <content type="text"><![CDATA[数字48-57 英文小写 a-z97-122 大写 A-Z65-90]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>实用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fhello-world.html</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
